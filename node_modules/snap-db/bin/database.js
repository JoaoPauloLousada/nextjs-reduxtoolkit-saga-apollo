Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var common_1 = require("./common");
var lib_bloom_1 = require("./lib_bloom");
var lib_rbtree_1 = require("./lib_rbtree");
var snapCompare = function (a, b) {
    if (a === b)
        return 0;
    if (typeof a === typeof b)
        return a > b ? 1 : -1;
    return typeof a > typeof b ? 1 : -1;
};
var SnapDatabase = /** @class */ (function () {
    function SnapDatabase(_path, keyType, memoryCache, autoFlush, isWorker) {
        var _this = this;
        this._path = _path;
        this.keyType = keyType;
        this.memoryCache = memoryCache;
        this.autoFlush = autoFlush;
        this.isWorker = isWorker;
        this._cache = {};
        this._memTable = lib_rbtree_1.createRBTree(snapCompare);
        this._memTableSize = 0;
        this._manifestData = {
            v: common_1.VERSION,
            inc: 0,
            lvl: []
        };
        this._doingTx = false;
        this._isCompacting = false;
        this._isConnecting = false;
        this.txNum = Math.round(Math.random() * 256);
        this._bloomCache = {};
        this._indexFileCache = {};
        this._index = lib_rbtree_1.createRBTree(snapCompare);
        this._maybeCacheClear = common_1.throttle(this, function () {
            // clear out cache that wasn't used more than 10 seconds ago
            var deleteTime = Date.now() + 10000;
            var indexIDs = Object.keys(_this._indexFileCache);
            var i = 0;
            while (i < indexIDs.length) {
                var fileNum = indexIDs[i];
                var cache = _this._indexFileCache[fileNum];
                if (cache.lastUsed > deleteTime) {
                    delete _this._indexFileCache[fileNum];
                }
                i++;
            }
            i = 0;
            var bloomIDs = Object.keys(_this._bloomCache);
            while (i < bloomIDs.length) {
                var fileNum = bloomIDs[i];
                var cache = _this._bloomCache[fileNum];
                if (cache.lastUsed > deleteTime) {
                    delete _this._bloomCache[fileNum];
                }
                i++;
            }
        }, 5000);
        this.iterators = {};
        this._getFiles();
        if (this.isWorker) {
            this._listenForCommands();
        }
    }
    SnapDatabase.prototype._getFiles = function () {
        try {
            if (!fs.existsSync(this._path)) {
                fs.mkdirSync(this._path, { recursive: true });
            }
            // create the log file if it's not there.
            this._logHandle = fs.openSync(path.join(this._path, "LOG"), "a+");
            // restore from crash/partial write
            if (fs.existsSync(path.join(this._path, "manifest-temp.json"))) {
                try {
                    // if the JSON is invalid this whole block fails to run
                    // either manifest.json is valid OR manifest-temp.json is valid
                    // so if this fails the main mainfest should be good to use.
                    this._manifestData = JSON.parse((fs.readFileSync(path.join(this._path, "manifest-temp.json")) || Buffer.from([])).toString("utf-8") || '{"inc": 0, "lvl": []}');
                    // write to main manifest
                    fs.writeFileSync(path.join(this._path, "manifest.json"), JSON.stringify(this._manifestData));
                    var fd2 = fs.openSync(path.join(this._path, "manifest.json"), "rs+");
                    fs.fsyncSync(fd2);
                    fs.closeSync(fd2);
                    fs.unlinkSync(path.join(this._path, "manifest-temp.json"));
                }
                catch (e) {
                    // temporary manifest failed to load
                    try {
                        // try to load main manifest file
                        this._manifestData = JSON.parse(fs.readFileSync(path.join(this._path, "manifest.json")).toString("utf-8"));
                    }
                    catch (e) {
                        console.error(e);
                        throw new Error("manifest.json is damaged or not found, unable to load database");
                    }
                    try {
                        fs.unlinkSync(path.join(this._path, "manifest-temp.json"));
                    }
                    catch (e) {
                    }
                }
            }
            else if (fs.existsSync(path.join(this._path, "manifest.json"))) {
                try {
                    // try to load main manifest file
                    this._manifestData = JSON.parse(fs.readFileSync(path.join(this._path, "manifest.json")).toString("utf-8"));
                }
                catch (e) {
                    console.error(e);
                    throw new Error("manifest.json is damaged, unable to load database");
                }
            }
            if (this._manifestData.v <= 1.09) { // use old log parsing method
                // move old log file
                if (!fs.existsSync(path.join(this._path, "LOG-109"))) {
                    fs.closeSync(this._logHandle);
                    fs.renameSync(path.join(this._path, "LOG"), path.join(this._path, "LOG-109"));
                    // init new log file
                    this._logHandle = fs.openSync(path.join(this._path, "LOG"), "a+");
                }
                // load everything using old format
                this._loadKeysFromV109();
                // remove old log
                fs.unlinkSync(path.join(this._path, "LOG-109"));
                // migrate version number
                this._manifestData.v = common_1.VERSION;
                common_1.writeManifestUpdate(this._path, this._manifestData);
            }
            else {
                this._manifestData.v = common_1.VERSION;
                common_1.writeManifestUpdate(this._path, this._manifestData);
                this._loadKeysAndLog();
            }
        }
        catch (e) {
            console.error("Problem creating or reading database files.");
            console.error(e);
        }
    };
    SnapDatabase.prototype.exists = function (key) {
        // check cache first
        if (this.memoryCache) {
            if (typeof this._cache[key] !== "undefined") {
                return true;
            }
            else {
                return false;
            }
        }
        // check memtable
        var memValue = this._memTable.get(key);
        if (typeof memValue !== "undefined") {
            if (memValue === common_1.NULLBYTE) { // tombstone
                return false;
            }
            return true;
        }
        // check index
        var index = this._index.get(key);
        if (typeof index !== "undefined") {
            return true;
        }
        return false;
    };
    SnapDatabase.prototype.delete = function (key) {
        this._index = this._index.remove(key);
        var keyStr = (this.keyType === "any" ? (typeof key === "number" ? "n>" : "s>") : "") + String(key);
        var keyLen = keyStr.length;
        fs.writeSync(this._logHandle, common_1.NULLBYTE);
        this._memTableSize++;
        var tombStone = keyLen + "," + keyStr + ",-1";
        var hash = "," + String(lib_bloom_1.MurmurHash3(0, tombStone));
        fs.writeSync(this._logHandle, ":" + tombStone);
        fs.writeSync(this._logHandle, hash);
        this._memTableSize += tombStone.length + hash.length + 1;
        // flush to disk
        if (!this._doingTx) {
            fs.fsyncSync(this._logHandle);
        }
        if (typeof this._memTable.get(key) !== "undefined") {
            this._memTable = this._memTable.remove(key);
        }
        this._memTable = this._memTable.insert(key, common_1.NULLBYTE);
        delete this._cache[key];
        if (!this._doingTx)
            this.maybeFlushLog();
        return key;
    };
    SnapDatabase.prototype.put = function (key, value) {
        // write key to index
        this._index = this._index.insert(key, common_1.NULLBYTE);
        if (this.memoryCache) {
            this._cache[key] = value;
        }
        var keyStr = (this.keyType === "any" ? (typeof key === "number" ? "n>" : "s>") : "") + String(key);
        var valueStr = String(value);
        // mark key in memtable
        if (typeof this._memTable.get(key) !== "undefined") {
            this._memTable = this._memTable.remove(key);
        }
        var meta = keyStr.length + "," + keyStr + "," + (this._memTableSize + 1) + "," + valueStr.length;
        var hash = "," + String(lib_bloom_1.MurmurHash3(0, meta + valueStr));
        // write value to log
        fs.writeSync(this._logHandle, common_1.NULLBYTE);
        fs.writeSync(this._logHandle, valueStr);
        fs.writeSync(this._logHandle, ":" + meta);
        fs.writeSync(this._logHandle, hash);
        this._memTable = this._memTable.insert(key, { fileID: -1, offset: [(this._memTableSize + 1), valueStr.length] });
        this._memTableSize++; // NULL
        this._memTableSize += valueStr.length;
        this._memTableSize += 1 + meta.length;
        this._memTableSize += hash.length;
        if (this.memoryCache) {
            this._cache[key] = value;
        }
        // flush to disk
        if (!this._doingTx) {
            fs.fsyncSync(this._logHandle);
            this.maybeFlushLog();
        }
    };
    SnapDatabase.prototype._getBloom = function (fileID) {
        if (this._bloomCache[fileID]) {
            this._bloomCache[fileID].lastUsed = Date.now();
            return this._bloomCache[fileID].cache;
        }
        this._bloomCache[fileID] = { cache: JSON.parse(fs.readFileSync(path.join(this._path, common_1.fileName(fileID) + ".bom"), "utf-8")), lastUsed: Date.now() };
        return this._bloomCache[fileID].cache;
    };
    SnapDatabase.prototype._maybeGetValue = function (strKey, fileID) {
        var index = this._indexFileCache[fileID] ? this._indexFileCache[fileID].cache : JSON.parse(fs.readFileSync(path.join(this._path, common_1.fileName(fileID) + ".idx"), "utf-8"));
        if (this._indexFileCache[fileID]) {
            this._indexFileCache[fileID].lastUsed = Date.now();
        }
        else {
            this._indexFileCache[fileID] = { cache: index, lastUsed: Date.now() };
        }
        if (typeof index.keys[strKey] !== "undefined") { // bloom filter miss if undefined
            var dataStart = index.keys[strKey][0];
            var dataLength = index.keys[strKey][1];
            // tombstone found
            if (dataStart === -1) {
                return { type: "data", data: undefined };
            }
            // data found
            var fd = fs.openSync(path.join(this._path, common_1.fileName(fileID) + ".dta"), "r");
            var buff = Buffer.alloc(dataLength);
            fs.readSync(fd, buff, 0, dataLength, dataStart);
            fs.closeSync(fd);
            return { type: "data", data: buff.toString("utf-8") };
        }
        return { type: "miss", data: undefined };
    };
    SnapDatabase.prototype.get = function (key, skipCache) {
        this._maybeCacheClear();
        // check cache first
        if (this.memoryCache && !skipCache) {
            if (typeof this._cache[key] !== "undefined") {
                return this._cache[key];
            }
            else {
                return undefined;
            }
        }
        // check if it's in the index at all
        if (this.exists(key) === false)
            return undefined;
        // check memtable
        var memValue = this._memTable.get(key);
        if (typeof memValue !== "undefined") { // found value in mem table
            if (memValue === common_1.NULLBYTE) { // tombstone
                return undefined;
            }
            var buff = Buffer.alloc(memValue.offset[1]); // length/size
            fs.readSync(this._logHandle, buff, 0, memValue.offset[1], memValue.offset[0]);
            return buff.toString("utf-8");
        }
        // find latest key entry on disk
        var i = 0;
        while (i < this._manifestData.lvl.length) { // go through each level, starting at level 0
            var lvl = this._manifestData.lvl[i];
            var k = 0;
            while (k < lvl.files.length) { // loop through all files in this level
                var fileInfo = lvl.files[k];
                if (fileInfo.range[0] <= key && fileInfo.range[1] >= key) {
                    var bloom = this._getBloom(fileInfo.i);
                    var strKey = String(key);
                    if (lib_bloom_1.BloomFilter.contains(bloom.vData, bloom.nHashFuncs, bloom.nTweak, strKey)) {
                        var value = this._maybeGetValue(strKey, fileInfo.i);
                        if (value.type !== "miss")
                            return value.data;
                    }
                }
                k++;
            }
            i++;
        }
        return undefined;
    };
    SnapDatabase.prototype.maybeFlushLog = function (forceFlush) {
        var _this = this;
        if (this._doingTx || this._isCompacting) {
            return;
        }
        var OneMB = 1000000;
        if (this.autoFlush === false && !forceFlush) {
            return;
        }
        var maxSize = typeof this.autoFlush === "boolean" ? 2 * OneMB : this.autoFlush * OneMB;
        // flush log & memtable
        if (this._memTableSize > maxSize || forceFlush) {
            var level0Files_1 = this._manifestData.lvl && this._manifestData.lvl.length ? this._manifestData.lvl[0].files.map(function (f) { return f.i; }) : [];
            common_1.tableGenerator(0, this._manifestData, this._path, this._memTable, function () {
                // remove old level 0 files from manifest
                _this._manifestData.lvl[0].files = _this._manifestData.lvl[0].files.filter(function (f) {
                    return level0Files_1.indexOf(f.i) === -1;
                });
                // update manifest to disk
                common_1.writeManifestUpdate(_this._path, _this._manifestData);
                // empty memtable
                _this._memTable = lib_rbtree_1.createRBTree(snapCompare);
                _this._memTableSize = 0;
                // empty logfile
                fs.closeSync(_this._logHandle);
                try {
                    fs.unlinkSync(path.join(_this._path, "LOG"));
                }
                catch (e) {
                }
                _this._logHandle = fs.openSync(path.join(_this._path, "LOG"), "a+");
                // delete old level files
                level0Files_1.forEach(function (fileID) {
                    try {
                        fs.unlinkSync(path.join(_this._path, common_1.fileName(fileID) + ".dta"));
                        fs.unlinkSync(path.join(_this._path, common_1.fileName(fileID) + ".idx"));
                        fs.unlinkSync(path.join(_this._path, common_1.fileName(fileID) + ".bom"));
                    }
                    catch (e) {
                        // no error if the delete fails, doesn't matter
                    }
                });
                _this._maybeCompact();
            });
        }
    };
    SnapDatabase.prototype._maybeCompact = function () {
        this._isCompacting = true;
        if (process.send)
            process.send({ type: "snap-compact" });
    };
    SnapDatabase.prototype.startTX = function () {
        var newTXNum = 0;
        while (newTXNum === 0 || newTXNum === this.txNum) {
            newTXNum = Math.round(Math.random() * 256);
        }
        this.txNum = newTXNum;
        fs.writeSync(this._logHandle, common_1.NULLBYTE);
        this._memTableSize++;
        var startTX = "TX-START-" + this.txNum;
        fs.writeSync(this._logHandle, startTX);
        this._memTableSize += startTX.length;
        this._doingTx = true;
    };
    SnapDatabase.prototype.endTX = function () {
        fs.writeSync(this._logHandle, common_1.NULLBYTE);
        this._memTableSize++;
        var endTX = "TX-END-" + this.txNum;
        fs.writeSync(this._logHandle, endTX);
        this._memTableSize += endTX.length;
        fs.fsyncSync(this._logHandle);
        this._doingTx = false;
        this.maybeFlushLog();
    };
    SnapDatabase.prototype.compactDone = function () {
        this._isCompacting = false;
        this._manifestData = JSON.parse((fs.readFileSync(path.join(this._path, "manifest.json")) || Buffer.from([])).toString("utf-8"));
        this._bloomCache = {};
        this._indexFileCache = {};
    };
    SnapDatabase.prototype.getCount = function () {
        return this._index.length();
    };
    SnapDatabase.prototype.close = function () {
        // clear index
        this._index = lib_rbtree_1.createRBTree(snapCompare);
        this._memTable = lib_rbtree_1.createRBTree(snapCompare);
        // close log file
        fs.closeSync(this._logHandle);
        this._bloomCache = {};
        this._indexFileCache = {};
    };
    SnapDatabase.prototype.clear = function () {
        this._isCompacting = true;
        this._index = lib_rbtree_1.createRBTree(snapCompare);
        this._memTable = lib_rbtree_1.createRBTree(snapCompare);
        this._memTableSize = 0;
        fs.closeSync(this._logHandle);
        // clear database
        // remove all files in db folder
        try {
            var files = fs.readdirSync(this._path);
            for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                var file = files_1[_i];
                fs.unlinkSync(path.join(this._path, file));
            }
        }
        catch (e) {
        }
        // setup new manifest and log
        this._getFiles();
        this._isCompacting = false;
        this._doingTx = false;
    };
    SnapDatabase.prototype.newIterator = function (queryArgs) {
        var id = common_1.rand();
        while (this.iterators[id]) {
            id = common_1.rand();
        }
        if (queryArgs.offset !== undefined) {
            this.iterators[id] = { it: queryArgs.reverse ? this._index.end() : this._index.begin(), r: queryArgs.reverse || false, limit: queryArgs.limit || -1, count: 0 };
            var i = queryArgs.offset;
            while (i-- && this.iterators[id].it.valid()) {
                if (queryArgs.reverse) {
                    this.iterators[id].it.prev();
                }
                else {
                    this.iterators[id].it.next();
                }
            }
        }
        else {
            if (queryArgs.reverse) {
                var end = queryArgs.lt !== undefined ? this._index.lt(queryArgs.lt) : (queryArgs.lte !== undefined ? this._index.le(queryArgs.lte) : this._index.end());
                this.iterators[id] = { it: end, r: true, limit: queryArgs.limit || -1, end: queryArgs.gt, endE: queryArgs.gte, count: 0 };
            }
            else {
                var start = queryArgs.gt !== undefined ? this._index.gt(queryArgs.gt) : (queryArgs.gte !== undefined ? this._index.ge(queryArgs.gte) : this._index.begin());
                this.iterators[id] = { it: start, r: false, limit: queryArgs.limit || -1, end: queryArgs.lt, endE: queryArgs.lte, count: 0 };
            }
        }
        return id;
    };
    SnapDatabase.prototype.clearIterator = function (id) {
        delete this.iterators[id];
    };
    SnapDatabase.prototype.nextIterator = function (id) {
        if (this.iterators[id].it.valid()) {
            var key = this.iterators[id].it.key();
            var reverse = this.iterators[id].r;
            var limitFinished = this.iterators[id].limit === -1 ? false : this.iterators[id].count >= this.iterators[id].limit;
            var rangeFinished1 = this.iterators[id].end !== undefined ? (reverse ? key < this.iterators[id].end : key > this.iterators[id].end) : false;
            var rangeFinished2 = this.iterators[id].endE !== undefined ? (reverse ? key <= this.iterators[id].endE : key >= this.iterators[id].endE) : false;
            if (!limitFinished && !rangeFinished1 && !rangeFinished2) {
                this.iterators[id].count++;
                if (this.iterators[id].r) {
                    this.iterators[id].it.prev();
                }
                else {
                    this.iterators[id].it.next();
                }
                return { key: key, done: false };
            }
            else {
                return { key: undefined, done: true };
            }
        }
        else {
            return { key: undefined, done: true };
        }
    };
    SnapDatabase.prototype._listenForCommands = function () {
        var _this = this;
        process.on('message', function (msg) {
            var key = msg.key;
            var msgId = msg.id;
            switch (msg.type) {
                case "compact-done":
                    _this.compactDone();
                    if (process.send)
                        process.send({ type: "snap-compact-done", id: msgId });
                    if (_this._isConnecting) {
                        _this._isConnecting = false;
                        _this.ready = true;
                        if (process.send)
                            process.send({ type: "snap-ready" });
                    }
                    break;
                case "do-compact":
                    _this.maybeFlushLog(true);
                    break;
                case "snap-new-iterator":
                    try {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, data: [undefined, _this.newIterator(msg.args[0])] });
                    }
                    catch (e) {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, data: ["Failed to make iterator!", ""] });
                    }
                    break;
                case "snap-next-iterator":
                    try {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, data: [undefined, _this.nextIterator(msg.args[0])] });
                    }
                    catch (e) {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, data: ["Failed to get next iterator value!", ""] });
                    }
                    break;
                case "snap-clear-iterator":
                    try {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, data: [undefined, _this.clearIterator(msg.args[0])] });
                    }
                    catch (e) {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, data: ["Failed to clear iterator value!", ""] });
                    }
                    break;
                case "snap-get":
                    try {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, event: "get", data: [undefined, _this.get(key)] });
                    }
                    catch (e) {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, event: "get", data: ["Unable to get key or key not found!", ""] });
                    }
                    break;
                case "snap-exists":
                    try {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, event: "exists", data: [undefined, _this.exists(key)] });
                    }
                    catch (e) {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, event: "exists", data: ["Unable to run exists query!", ""] });
                    }
                    break;
                case "snap-del":
                    try {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, event: "delete", data: [undefined, _this.delete(key)] });
                    }
                    catch (e) {
                        console.error(e);
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, event: "delete", data: ["Unable to delete key! " + key] });
                    }
                    break;
                case "snap-put":
                    try {
                        _this.put(key, msg.value);
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, event: "put", data: [undefined, true] });
                    }
                    catch (e) {
                        console.error(e);
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msgId, event: "put", data: ["Error writing value!"] });
                    }
                    break;
                case "snap-count":
                    if (process.send)
                        process.send({ type: "snap-res-done", id: msg.id, event: "get-count", data: [undefined, _this.getCount()] });
                    break;
                case "snap-start-tx":
                    if (_this._doingTx === true) {
                        if (process.send)
                            process.send({ type: "snap-res-done", id: msg.id, data: ["Can't do nested transactions, finish the current one first!", ""] });
                        return;
                    }
                    _this.startTX();
                    if (process.send)
                        process.send({ type: "snap-res-done", id: msg.id, event: "tx-start", data: [undefined, _this.txNum] });
                    break;
                case "snap-end-tx":
                    _this.endTX();
                    if (process.send)
                        process.send({ type: "snap-res-done", id: msg.id, event: "tx-end", data: [undefined, _this.txNum] });
                    break;
                case "snap-close":
                    _this.close();
                    if (process.send)
                        process.send({ type: "snap-close-done", id: msg.id, data: [undefined] });
                    break;
                case "snap-clear":
                    _this.clear();
                    if (process.send)
                        process.send({ type: "snap-clear-done", id: msg.id, data: [] });
                    break;
            }
        });
    };
    /**
     * Loads previously saved data into cache if cache is enabled.
     *
     * @private
     * @param {() => void} complete
     * @param {(err) => void} onErr
     * @returns
     * @memberof SnapDB
     */
    SnapDatabase.prototype._loadCache = function () {
        var total = this._index.length();
        if (total === 0 || !this.memoryCache) {
            return;
        }
        var it = this._index.begin();
        while (it.hasNext()) {
            this._cache[it.key()] = this.get(it.key(), true) || "";
            it.next();
        }
    };
    /**
     * Get all the keys from log files and index files
     *
     * @private
     * @memberof SnapDB
     */
    SnapDatabase.prototype._loadKeysAndLog = function () {
        var _this = this;
        // populate index from database files
        this._readIndexFiles();
        // load LOG file into memtable
        var logFileSize = fs.fstatSync(this._logHandle).size;
        if (logFileSize === 0) {
            // load cache if it's enabled
            this._loadCache();
            // nothing to load, all done
            this.ready = true;
            if (process.send)
                process.send({ type: "snap-ready" });
        }
        else {
            var readStream = fs.createReadStream(path.join(this._path, "LOG"), { autoClose: false, fd: this._logHandle });
            var buffer_1 = "";
            var tx_1 = -1;
            var txKeys_1 = [];
            var processLog_1 = function (line) {
                if (!line || !line.length)
                    return;
                if (line.indexOf("TX-START") === 0) { // start transaction
                    tx_1 = parseInt(line.replace("TX-START-", ""));
                    txKeys_1 = [];
                }
                else if (line.indexOf("TX-END") === 0) { // end of transaction
                    if (parseInt(line.replace("TX-END-", "")) === tx_1) {
                        var j = 0; // commit transaction to memtable
                        while (j < txKeys_1.length) {
                            _this._index = _this._index.remove(txKeys_1[j][0]);
                            _this._memTable = _this._memTable.remove(txKeys_1[j][0]);
                            if (txKeys_1[j][1] === -1) { // tombstone
                                _this._memTable = _this._memTable.insert(txKeys_1[j][0], common_1.NULLBYTE);
                            }
                            else {
                                _this._index = _this._index.insert(txKeys_1[j][0], common_1.NULLBYTE);
                                _this._memTable = _this._memTable.insert(txKeys_1[j][0], { fileID: -1, offset: [txKeys_1[j][1], txKeys_1[j][2]] });
                            }
                            j++;
                        }
                    }
                    tx_1 = -1;
                    txKeys_1 = [];
                }
                else { // normal line
                    var k = line.length;
                    var keyData = "";
                    var stop_1 = false;
                    var valueBreak = 0;
                    while (k-- && stop_1 === false) {
                        if (line[k] === ":") {
                            valueBreak = k;
                            stop_1 = true;
                        }
                        else {
                            keyData = line[k] + keyData;
                        }
                    }
                    stop_1 = false;
                    k = 0;
                    var keyLenStr = "";
                    var ptr = 0;
                    while (k < keyData.length && stop_1 === false) {
                        ptr++;
                        if (keyData[k] === ",") {
                            stop_1 = true;
                        }
                        else {
                            keyLenStr = keyLenStr + keyData[k];
                        }
                        k++;
                    }
                    var keyLength = parseInt(keyLenStr);
                    if (isNaN(keyLength)) {
                        throw new Error("Error parsing log file!");
                    }
                    k = 0;
                    var key = "";
                    while (k < keyLength) {
                        key += keyData[k + ptr];
                        k++;
                    }
                    ptr += keyLength + 1;
                    var parsedKey = _this.keyType === "any" ? (key.slice(0, 2) === "n>" ? parseFloat(key.slice(2)) : key.slice(2)) : (_this.keyType === "string" ? key : parseFloat(key));
                    var parsedValueData = keyData.substr(ptr).split(",").map(function (s) { return parseInt(s); });
                    _this._memTable = _this._memTable.remove(parsedKey);
                    _this._index = _this._index.remove(parsedKey);
                    if (parsedValueData[0] === -1) { // tombstone
                        if (tx_1 !== -1) {
                            txKeys_1.push([parsedKey, -1, 0]);
                        }
                        else {
                            _this._memTable = _this._memTable.insert(parsedKey, common_1.NULLBYTE);
                        }
                    }
                    else { // value
                        var start = parsedValueData[0];
                        var length_1 = parsedValueData[1];
                        var hash = parsedValueData[2];
                        if (hash === lib_bloom_1.MurmurHash3(0, keyLength + "," + key + "," + start + "," + length_1 + line.substr(0, valueBreak))) {
                            _this._index = _this._index.insert(parsedKey, common_1.NULLBYTE);
                            if (tx_1 !== -1) {
                                txKeys_1.push([parsedKey, start, length_1]);
                            }
                            else {
                                _this._memTable = _this._memTable.insert(parsedKey, { fileID: -1, offset: [start, length_1] });
                            }
                        }
                        else {
                            console.error("Error validating key \"" + parsedKey + "\", value not imported from log!");
                        }
                    }
                }
            };
            var size_1 = 0;
            readStream.on("data", function (chunk) {
                var i = 0;
                while (i < chunk.length) {
                    if (chunk[i] === 0 && buffer_1.length) {
                        processLog_1(buffer_1);
                        buffer_1 = "";
                    }
                    else if (chunk[i] !== 0) {
                        buffer_1 += String.fromCharCode(chunk[i]);
                    }
                    i++;
                }
                size_1 += chunk.length;
            }).on("end", function () {
                if (buffer_1.length) {
                    processLog_1(buffer_1);
                    buffer_1 = "";
                }
                _this._isConnecting = true;
                _this._memTableSize = size_1;
                // purge keys that are in an incomplete transaction
                if (tx_1 !== -1) {
                    var i = txKeys_1.length;
                    while (i--) {
                        _this._memTable = _this._memTable.remove(txKeys_1[i]);
                    }
                }
                // load cache if it's enabled
                _this._loadCache();
                // flush logs if needed
                _this.maybeFlushLog();
                _this.ready = true;
                if (process.send)
                    process.send({ type: "snap-ready" });
            });
        }
    };
    /**
     * Get all the keys from log files and index files
     *
     * @private
     * @memberof SnapDB
     */
    SnapDatabase.prototype._loadKeysFromV109 = function () {
        var _this = this;
        var parseLogLine = function (line) {
            // log record line:
            // keyKength,valueLength,key value hash
            var buffer = "";
            var i = 0;
            while (line[i] !== "," && i < line.length) {
                buffer += line[i];
                i++;
            }
            i++;
            var keyLen = parseInt(buffer);
            buffer = "";
            if (isNaN(keyLen)) {
                throw new Error("Error parsing log file!");
            }
            while (line[i] !== "," && i < line.length) {
                buffer += line[i];
                i++;
            }
            i++;
            var valueLen = parseInt(buffer);
            buffer = "";
            if (isNaN(valueLen)) {
                throw new Error("Error parsing log file!");
            }
            var k = 0;
            while (k < keyLen && k < line.length) {
                buffer += line[i + k];
                k++;
            }
            var key = _this.keyType === "string" ? buffer : parseFloat(buffer);
            if (valueLen === -1) { // tombstone
                return [key, -1];
            }
            buffer = "";
            k = 0;
            while (k < valueLen && k < line.length) {
                buffer += line[i + k + keyLen];
                k++;
            }
            var value = buffer;
            buffer = "";
            k = i + keyLen + valueLen;
            while (k < line.length) {
                buffer += line[k];
                k++;
            }
            if (lib_bloom_1.MurmurHash3(0, String(key) + value) !== parseInt(buffer)) {
                console.warn("Integrity check failed for the following key, value not imported.");
                console.warn(key);
                return [];
            }
            return [key, value];
        };
        // populate index
        this._readIndexFiles();
        // load LOG file into memtable
        var LOGFILE = fs.readFileSync(path.join(this._path, "LOG-109"));
        if (LOGFILE.length === 0) {
            // nothing to load, all done
            // load cache if it's enabled
            this._loadCache();
            this.ready = true;
            if (process.send)
                process.send({ type: "snap-ready" });
        }
        else {
            // import logfile into merge tree
            var events = [];
            var buffer = "";
            var i = 0;
            while (i < LOGFILE.length) {
                if (LOGFILE[i] === 0) {
                    events.push(buffer);
                    buffer = "";
                }
                else {
                    buffer += String.fromCharCode(LOGFILE[i]);
                }
                i++;
            }
            events.push(buffer);
            buffer = "";
            var tx_2 = 0;
            var batches_1 = [];
            events.filter(function (v) { return v && v.length; }).forEach(function (event) {
                if (event.indexOf("TX-START-") === 0) { // start transaction
                    // clear previouse transaction data
                    tx_2 = parseInt(event.replace("TX-START-", ""));
                    batches_1 = [];
                }
                else if (event.indexOf("TX-END-") === 0) { // end of transaction
                    var endTx = tx_2 = parseInt(event.replace("TX-END-", ""));
                    if (endTx === tx_2) { // commit batch
                        batches_1.forEach(function (bEvent) {
                            var rowData = parseLogLine(bEvent);
                            var key = _this.keyType === "string" ? rowData[0] : parseFloat(rowData[0]);
                            if (rowData.length) {
                                if (rowData[1] === -1) {
                                    _this.delete(key);
                                }
                                else {
                                    _this.put(key, rowData[1]);
                                }
                            }
                        });
                        batches_1 = [];
                    }
                    tx_2 = 0;
                }
                else { // normal record
                    if (tx_2 === 0) { // not in transaction
                        var rowData = parseLogLine(event);
                        var key = _this.keyType === "string" ? rowData[0] : parseFloat(rowData[0]);
                        if (rowData.length) {
                            if (rowData[1] === -1) {
                                _this.delete(key);
                            }
                            else {
                                _this.put(key, rowData[1]);
                            }
                        }
                    }
                    else { // in transaction
                        batches_1.push(event);
                    }
                }
            });
            this._isConnecting = true;
            // load cache if it's enabled
            this._loadCache();
            // flush logs if needed
            this.maybeFlushLog();
            this.ready = true;
            if (process.send)
                process.send({ type: "snap-ready" });
        }
    };
    SnapDatabase.prototype._readIndexFiles = function () {
        var _this = this;
        fs.readdir(this._path, function (err, filenames) {
            if (err) {
                throw err;
            }
            filenames.sort(function (a, b) { return a > b ? 1 : -1; }).forEach(function (filename) {
                if (filename.indexOf(".idx") !== -1) {
                    fs.readFile(path.join(_this._path, filename), 'utf-8', function (err, content) {
                        if (err) {
                            throw err;
                        }
                        if (content && content.length) {
                            var index = JSON.parse(content);
                            var keys = Object.keys(index.keys);
                            var i = keys.length;
                            while (i--) {
                                var key = _this.keyType === "any" ? (keys[i].slice(0, 2) === "n>" ? parseFloat(keys[i].slice(2)) : keys[i].slice(2)) : (_this.keyType === "string" ? keys[i] : parseFloat(keys[i]));
                                if (index.keys[keys[i]][0] === -1) { // delete
                                    _this._index = _this._index.remove(key);
                                }
                                else { // add
                                    _this._index = _this._index.insert(key, "");
                                }
                            }
                        }
                    });
                }
            });
        });
    };
    return SnapDatabase;
}());
exports.SnapDatabase = SnapDatabase;
// this is child fork if process.send exists
if (process.send !== undefined) {
    process.on('message', function (msg) {
        switch (msg.type) {
            case "snap-connect":
                new SnapDatabase(msg.path, msg.keyType, msg.cache, msg.autoFlush, true);
                break;
        }
    });
}
//# sourceMappingURL=database.js.map