Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
require("mocha");
var index_1 = require("./index");
function makeid() {
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (var i = 0; i < Math.ceil(Math.random() * 40) + 10; i++)
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    return text;
}
exports.runTests = function (testName, new_str, new_int, new_flt, new_any) {
    var data = {};
    var db_str = new_str();
    var db_int = new_int();
    var db_flt = new_flt();
    var db_any = new_any();
    describe(testName, function () {
        it("Put Data", function (done) {
            var size = 1000;
            Promise.all([db_str, db_int, db_flt, db_any].map(function (s, i) {
                var dataKey = ["str", "int", "flt", "any"][i];
                data[dataKey] = [];
                for (var k = 0; k < size; k++) {
                    switch (i) {
                        case 0:
                            data[dataKey].push([makeid(), makeid()]);
                            break;
                        case 1:
                            data[dataKey].push([k, makeid()]);
                            break;
                        case 2:
                            data[dataKey].push([k + (Math.round(Math.random() * 8) / 10), makeid()]);
                            break;
                        case 3:
                            var dice = Math.floor(Math.random() * 3);
                            switch (dice) {
                                case 0:
                                    data[dataKey].push([k, makeid()]);
                                    break;
                                case 1:
                                    data[dataKey].push([k + (Math.round(Math.random() * 8) / 10), makeid()]);
                                    break;
                                case 2:
                                    data[dataKey].push([makeid(), makeid()]);
                                    break;
                            }
                            break;
                    }
                }
                // scramble for insert
                data[dataKey] = data[dataKey].sort(function (a, b) { return Math.random() > 0.5 ? 1 : -1; });
                return Promise.all(data[dataKey].map(function (k) { return s.put(k[0], k[1]); }));
            })).then(function () {
                Promise.all([
                    db_str.getCount(),
                    db_int.getCount(),
                    db_flt.getCount()
                ]).then(function (result) {
                    try {
                        chai_1.expect(result).to.deep.equal([
                            size,
                            size,
                            size
                        ], "Put failed!");
                        done();
                    }
                    catch (e) {
                        done(e);
                    }
                });
            });
        }).timeout(30000);
        it("Get non-exist key", function (done) {
            db_str.get('non-exist-key').then(function (val) {
                try {
                    chai_1.expect(val).to.equal(undefined, "get a non-exist key should return undefined");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }).catch(done);
        });
        it("Call close() for multiple times", function (done) {
            var db = new index_1.SnapDB({ dir: "testDB-close", key: "string" });
            db.close()
                .then(function () { return db.close(); })
                .then(function () { return done(); })
                .catch(done);
        });
        it("Integer: Sorted Keys", function (done) {
            data["int"] = data["int"].sort(function (a, b) { return a[0] > b[0] ? 1 : -1; });
            var dataFromDB = [];
            db_int.getAll(function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["int"], "Integers not sorted!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("Integer: Key Exists", function (done) {
            var randomKey = data["int"][Math.floor(Math.random() * data["int"].length)][0];
            db_int.exists(randomKey).then(function (exists) {
                try {
                    chai_1.expect(exists).to.equal(true, "Integer key doesn't exist!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }).catch(done);
        });
        it("Integer: Key Doesn't Exist", function (done) {
            var impossibleKey = Date.now();
            db_int.exists(impossibleKey).then(function (exists) {
                try {
                    chai_1.expect(exists).to.equal(false, "Integer key exists!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }).catch(done);
        });
        it("Integer: Delete Key", function (done) {
            var thisValue = data["int"].splice(42, 1).pop();
            db_int.delete(thisValue[0]);
            var dataFromDB = [];
            db_int.getAll(function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["int"], "Integer key not deleted!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("Integer: Offset Select", function (done) {
            var dataFromDB = [];
            db_int.offset(100, 10, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    var genData = data["int"].slice(100, 110);
                    chai_1.expect(dataFromDB).to.deep.equal(genData, "Integer offset select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("Integer: Offset Select (Reverse)", function (done) {
            var dataFromDB = [];
            db_int.offset(100, 10, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    var genData = data["int"].slice().reverse().slice(100, 110);
                    chai_1.expect(dataFromDB).to.deep.equal(genData, "Integer offset reverse select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }, true);
        });
        it("Integer: Range Select", function (done) {
            var dataFromDB = [];
            db_int.range(20, 50, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    var genData = data["int"].filter(function (v) { return v[0] >= 20 && v[0] <= 50; });
                    chai_1.expect(dataFromDB).to.deep.equal(genData, "Integer range select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("Integer: Range Select (Reverse)", function (done) {
            var dataFromDB = [];
            db_int.range(20, 50, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    var genData = data["int"].slice().filter(function (v) { return v[0] >= 20 && v[0] <= 50; }).reverse();
                    chai_1.expect(dataFromDB).to.deep.equal(genData, "Integer range select reverse failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
                db_int.close();
            }, true);
        });
        it("Integer: Loading From Log Works", function (done) {
            db_int.close().then(function () {
                var db2 = new_int();
                var dataFromDB = [];
                db2.getAll(function (key, value) {
                    dataFromDB.push([key, value]);
                }, function () {
                    try {
                        chai_1.expect(dataFromDB).to.deep.equal(data["int"], "Failed to load database from logs!");
                        done();
                    }
                    catch (e) {
                        done(e);
                    }
                });
            });
        });
        it("Float: Sorted Keys", function (done) {
            data["flt"] = data["flt"].sort(function (a, b) { return a[0] > b[0] ? 1 : -1; });
            var dataFromDB = [];
            db_flt.getAll(function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["flt"], "Floats not sorted!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("Float: Key Exists", function (done) {
            var randomKey = data["flt"][Math.floor(Math.random() * data["flt"].length)][0];
            db_flt.exists(randomKey).then(function (exists) {
                try {
                    chai_1.expect(exists).to.equal(true, "Float key doesn't exist!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }).catch(done);
        });
        it("Float: Key Doesn't Exist", function (done) {
            var impossibleKey = Date.now();
            db_flt.exists(impossibleKey).then(function (exists) {
                try {
                    chai_1.expect(exists).to.equal(false, "Float key exists!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }).catch(done);
        });
        it("Float: Delete Key", function (done) {
            var thisValue = data["flt"].splice(42, 1).pop();
            db_flt.delete(thisValue[0]);
            var dataFromDB = [];
            db_flt.getAll(function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["flt"], "Float key not deleted!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("Float: Offset Select", function (done) {
            var dataFromDB = [];
            db_flt.offset(100, 10, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["flt"].slice(100, 110), "Float offset select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("Float: Offset Select (Reverse)", function (done) {
            var dataFromDB = [];
            db_flt.offset(100, 10, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    var len = db_flt.getCount();
                    var genData = data["flt"].slice().reverse().slice(100, 110);
                    chai_1.expect(dataFromDB).to.deep.equal(genData, "Float offset reverse select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }, true);
        });
        it("Float: Range Select", function (done) {
            var dataFromDB = [];
            db_flt.range(20.5, 50.5, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    var genData = data["flt"].filter(function (v) { return v[0] >= 20.5 && v[0] <= 50.5; });
                    chai_1.expect(dataFromDB).to.deep.equal(genData, "Float range select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("Float: Range Select (Reverse)", function (done) {
            var dataFromDB = [];
            db_flt.range(20.5, 50.5, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    var genData = data["flt"].slice().filter(function (v) { return v[0] >= 20.5 && v[0] <= 50.5; }).reverse();
                    chai_1.expect(dataFromDB).to.deep.equal(genData, "Float range select reverse failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
                db_flt.close();
            }, true);
        });
        it("Float: Loading From Log Works", function (done) {
            db_flt.close().then(function () {
                var db2 = new_flt();
                var dataFromDB = [];
                db2.getAll(function (key, value) {
                    dataFromDB.push([key, value]);
                }, function () {
                    try {
                        chai_1.expect(dataFromDB).to.deep.equal(data["flt"], "Failed to load database from logs!");
                        done();
                    }
                    catch (e) {
                        done(e);
                    }
                });
            });
        });
        it("String: Sorted Keys", function (done) {
            data["str"] = data["str"].sort(function (a, b) { return a[0] > b[0] ? 1 : -1; });
            var dataFromDB = [];
            db_str.getAll(function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["str"], "Strings not sorted!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("String: Key Exists", function (done) {
            var randomKey = data["str"][Math.floor(Math.random() * data["str"].length)][0];
            db_str.exists(randomKey).then(function (exists) {
                try {
                    chai_1.expect(exists).to.equal(true, "String key doesn't exist!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }).catch(done);
        });
        it("String: Key Doesn't Exist", function (done) {
            var impossibleKey = "There is no way this combination of letters and spaces will happen.";
            db_str.exists(impossibleKey).then(function (exists) {
                try {
                    chai_1.expect(exists).to.equal(false, "String key exists!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }).catch(done);
        });
        it("String: Delete Key", function (done) {
            var thisValue = data["str"].splice(42, 1).pop();
            db_str.delete(thisValue[0]);
            var dataFromDB = [];
            db_str.getAll(function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["str"], "String key not deleted!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("String: Offset Select", function (done) {
            var dataFromDB = [];
            db_str.offset(100, 10, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["str"].slice(100, 110), "String offset select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("String: Offset Select (Reverse)", function (done) {
            var dataFromDB = [];
            db_str.offset(100, 10, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    var len = db_str.getCount();
                    chai_1.expect(dataFromDB).to.deep.equal(data["str"].slice().reverse().slice(100, 110), "String offset reverse select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }, true);
        });
        it("String: Range Select", function (done) {
            var dataFromDB = [];
            db_str.range("a", "b", function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["str"].filter(function (v) { return v[0] > "a" && v[0] < "b"; }), "String range select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("String: Range Select (Reverse)", function (done) {
            var dataFromDB = [];
            db_str.range("a", "b", function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    var genData = data["str"].slice().filter(function (v) { return v[0] > "a" && v[0] < "b"; }).reverse();
                    chai_1.expect(dataFromDB).to.deep.equal(genData, "String range select reverse failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
                db_str.close();
            }, true);
        });
        it("String: Loading From Log Works", function (done) {
            db_str.close().then(function () {
                var db2 = new_str();
                var dataFromDB = [];
                db2.getAll(function (key, value) {
                    dataFromDB.push([key, value]);
                }, function () {
                    try {
                        chai_1.expect(dataFromDB).to.deep.equal(data["str"], "Failed to load database from logs!");
                        done();
                    }
                    catch (e) {
                        done(e);
                    }
                });
            });
        });
        it("Any: Sorted Keys", function (done) {
            data["any"] = data["any"].sort(function (a, b) {
                if (a[0] === b[0])
                    return 0;
                if (typeof a[0] === typeof b[0])
                    return a[0] > b[0] ? 1 : -1;
                return typeof a[0] > typeof b[0] ? 1 : -1;
            });
            var dataFromDB = [];
            db_any.getAll(function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["any"], "Any not sorted!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("Any: Key Exists", function (done) {
            var randomKey = data["any"][Math.floor(Math.random() * data["any"].length)][0];
            db_any.exists(randomKey).then(function (exists) {
                try {
                    chai_1.expect(exists).to.equal(true, "Any key doesn't exist!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }).catch(done);
        });
        it("Any: Key Doesn't Exist", function (done) {
            var impossibleKey = "There is no way this combination of letters and spaces will happen.";
            db_any.exists(impossibleKey).then(function (exists) {
                try {
                    chai_1.expect(exists).to.equal(false, "Any key exists!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }).catch(done);
        });
        it("Any: Delete Key", function (done) {
            var thisValue = data["any"].splice(42, 1).pop();
            db_any.delete(thisValue[0]).then(function () {
                var dataFromDB = [];
                db_any.getAll(function (key, value) {
                    dataFromDB.push([key, value]);
                }, function () {
                    try {
                        chai_1.expect(dataFromDB).to.deep.equal(data["any"], "Any key not deleted!");
                        done();
                    }
                    catch (e) {
                        done(e);
                    }
                });
            });
        });
        it("Any: Offset Select", function (done) {
            var dataFromDB = [];
            db_any.offset(100, 10, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["any"].slice(100, 110), "Any offset select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("Any: Offset Select (Reverse)", function (done) {
            var dataFromDB = [];
            db_any.offset(100, 10, function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    var len = db_any.getCount();
                    chai_1.expect(dataFromDB).to.deep.equal(data["any"].slice().reverse().slice(100, 110), "Any offset reverse select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            }, true);
        });
        it("Any: Range Select", function (done) {
            var dataFromDB = [];
            db_any.range("a", "b", function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    chai_1.expect(dataFromDB).to.deep.equal(data["any"].filter(function (v) { return v[0] > "a" && v[0] < "b"; }), "Any range select failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
            });
        });
        it("Any: Range Select (Reverse)", function (done) {
            var dataFromDB = [];
            db_any.range("a", "b", function (key, value) {
                dataFromDB.push([key, value]);
            }, function () {
                try {
                    var genData = data["any"].slice().filter(function (v) { return v[0] > "a" && v[0] < "b"; }).reverse();
                    chai_1.expect(dataFromDB).to.deep.equal(genData, "Any range select reverse failed!");
                    done();
                }
                catch (e) {
                    done(e);
                }
                db_any.close();
            }, true);
        });
        it("Any: Loading From Log Works", function (done) {
            db_any.close().then(function () {
                var db2 = new_any();
                var dataFromDB = [];
                db2.getAll(function (key, value) {
                    dataFromDB.push([key, value]);
                }, function () {
                    db2.close();
                    try {
                        chai_1.expect(dataFromDB).to.deep.equal(data["any"], "Failed to load database from logs!");
                        done();
                    }
                    catch (e) {
                        done(e);
                    }
                    process.exit();
                });
            });
        });
    });
};
//# sourceMappingURL=test.js.map