Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var common_1 = require("./common");
var lib_bloom_1 = require("./lib_bloom");
var lib_rbtree_1 = require("./lib_rbtree");
var SnapCompactor = /** @class */ (function () {
    function SnapCompactor(path, keyType, cache) {
        var _this = this;
        this.path = path;
        this.keyType = keyType;
        this.cache = cache;
        this._manifestData = {
            v: common_1.VERSION,
            inc: 0,
            lvl: []
        };
        this._bloomCache = {};
        this._indexFileCache = {};
        process.on("message", function (msg) {
            if (msg === "do-compact") {
                _this._runCompaction();
            }
        });
    }
    SnapCompactor.prototype._getBloom = function (fileID) {
        if (this._bloomCache[fileID]) {
            return this._bloomCache[fileID];
        }
        this._bloomCache[fileID] = JSON.parse(fs.readFileSync(path.join(this.path, common_1.fileName(fileID) + ".bom"), "utf-8"));
        return this._bloomCache[fileID];
    };
    SnapCompactor.prototype._runCompaction = function () {
        var _this = this;
        this._manifestData = JSON.parse((fs.readFileSync(path.join(this.path, "manifest.json")) || Buffer.from([])).toString("utf-8") || '{"inc": 0, "lvl": []}');
        var compactIndex = lib_rbtree_1.createRBTree();
        this._indexFileCache = {};
        var hasOlderValues = function (key, level) {
            var currentLevel = level + 1;
            var nextLevel = function () {
                if (_this._manifestData.lvl[currentLevel]) {
                    var i = _this._manifestData.lvl[currentLevel].files.length;
                    while (i--) {
                        var fileInfo = _this._manifestData.lvl[currentLevel].files[i];
                        if (fileInfo.range[0] <= key && fileInfo.range[1] >= key) {
                            var bloom = _this._getBloom(fileInfo.i);
                            if (lib_bloom_1.BloomFilter.contains(bloom.vData, bloom.nHashFuncs, bloom.nTweak, String(key))) {
                                return true;
                            }
                        }
                    }
                    currentLevel++;
                    return nextLevel();
                }
                return false;
            };
            return nextLevel();
        };
        var loadFile = function (fileID, level) {
            var index = JSON.parse(fs.readFileSync(path.join(_this.path, common_1.fileName(fileID) + ".idx"), "utf-8"));
            // const data = fs.readFileSync(path.join(this.path, fileName(fileID) + ".dta"), "utf-8");
            var keys = Object.keys(index.keys);
            var i = 0;
            while (i < keys.length) {
                var key = _this.keyType === "any" ? (keys[i].slice(0, 2) === "n>" ? parseFloat(keys[i].slice(2)) : keys[i].slice(2)) : (_this.keyType === "string" ? keys[i] : parseFloat(keys[i]));
                if (compactIndex.get(key) !== undefined) {
                    compactIndex = compactIndex.remove(key);
                }
                if (index.keys[keys[i]][0] === -1) { // tombstone
                    // if higher level has this key, keep tombstone.  Otherwise discard it
                    if (hasOlderValues(key, level)) {
                        compactIndex = compactIndex.insert(key, common_1.NULLBYTE);
                    }
                    else {
                        compactIndex = compactIndex.remove(key);
                    }
                }
                else {
                    // data.slice(index.keys[key][0], index.keys[key][0] + index.keys[key][1])
                    compactIndex = compactIndex.insert(key, { fileID: fileID, offset: index.keys[keys[i]] });
                }
                i++;
            }
            ;
        };
        var deleteFiles = [];
        var finishCompact = function () {
            // clear old files from manifest
            deleteFiles.forEach(function (fileInfo) {
                if (_this._manifestData.lvl[fileInfo[0]]) {
                    _this._manifestData.lvl[fileInfo[0]].files = _this._manifestData.lvl[fileInfo[0]].files.filter(function (file) {
                        if (file.i === fileInfo[1]) {
                            return false;
                        }
                        return true;
                    });
                }
            });
            _this._bloomCache = {};
            _this._indexFileCache = {};
            // Safe manifest update
            common_1.writeManifestUpdate(_this.path, _this._manifestData);
            if (process.send)
                process.send({ type: "compact-done", files: deleteFiles.map(function (f) { return f[1]; }) });
        };
        if (this._manifestData.lvl && this._manifestData.lvl.length) {
            var i_1 = 0;
            var didCompact_1 = false;
            // loop compaction until all levels are within limits
            var maybeFinishCompact_1 = function () {
                if (didCompact_1) {
                    i_1 = 0;
                    didCompact_1 = false;
                    nextLevel_1();
                }
                else {
                    finishCompact();
                }
            };
            // compact a specific level
            var nextLevel_1 = function () {
                if (i_1 < _this._manifestData.lvl.length) {
                    var lvl_1 = _this._manifestData.lvl[i_1];
                    var maxSizeMB = Math.pow(10, i_1 + 1);
                    var size = 0;
                    var k = 0;
                    while (k < lvl_1.files.length) {
                        var file = lvl_1.files[k];
                        var fName = common_1.fileName(file.i);
                        size += (fs.statSync(path.join(_this.path, fName) + ".dta").size / 1000000.0);
                        size += (fs.statSync(path.join(_this.path, fName) + ".idx").size / 1000000.0);
                        size += (fs.statSync(path.join(_this.path, fName) + ".bom").size / 1000000.0);
                        k++;
                    }
                    if (size > maxSizeMB) { // compact this level
                        didCompact_1 = true;
                        // loop compaction marker around
                        if (lvl_1.comp >= lvl_1.files.length) {
                            lvl_1.comp = 0;
                        }
                        // get keyrange for file we're compacting
                        var keyRange_1 = [];
                        lvl_1.files.forEach(function (file, k) {
                            if (lvl_1.comp === k) {
                                keyRange_1 = file.range;
                            }
                        });
                        // increment compaction marker for next compaction
                        lvl_1.comp++;
                        // find overlapping files in the next level
                        if (_this._manifestData.lvl[i_1 + 1]) {
                            _this._manifestData.lvl[i_1 + 1].files.forEach(function (file) {
                                if (file.range[0] >= keyRange_1[0] && file.range[1] <= keyRange_1[0]) { // is starting key in the range for this file?
                                    deleteFiles.push([i_1 + 1, file.i]);
                                    loadFile(file.i, i_1 + 1);
                                }
                                else if (file.range[0] >= keyRange_1[1] && file.range[1] <= keyRange_1[1]) { // is ending key in the range for this file?
                                    deleteFiles.push([i_1 + 1, file.i]);
                                    loadFile(file.i, i_1 + 1);
                                }
                                else if (file.range[0] >= keyRange_1[0] && file.range[1] <= keyRange_1[1]) { // are the keys in the file entirely overlapping?
                                    deleteFiles.push([i_1 + 1, file.i]);
                                    loadFile(file.i, i_1 + 1);
                                }
                            });
                        }
                        // grab newest changes
                        lvl_1.files.forEach(function (file, k) {
                            if (lvl_1.comp === k) {
                                // grab file at this level
                                deleteFiles.push([i_1, file.i]);
                                loadFile(file.i, i_1);
                            }
                        });
                        // write files to disk
                        common_1.tableGenerator(i_1 + 1, _this._manifestData, _this.path, compactIndex, function () {
                            compactIndex = lib_rbtree_1.createRBTree();
                            i_1++;
                            nextLevel_1();
                        });
                    }
                    else {
                        maybeFinishCompact_1();
                    }
                }
                else {
                    maybeFinishCompact_1();
                }
            };
            nextLevel_1();
        }
        else {
            finishCompact();
        }
    };
    return SnapCompactor;
}());
exports.SnapCompactor = SnapCompactor;
process.on('message', function (msg) {
    switch (msg.type) {
        case "snap-compact":
            new SnapCompactor(msg.path, msg.keyType, msg.cache);
            break;
    }
});
//# sourceMappingURL=compact.js.map