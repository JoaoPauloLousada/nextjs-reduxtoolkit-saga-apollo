Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var lib_bloom_1 = require("./lib_bloom");
var lib_sha1_1 = require("./lib_sha1");
exports.VERSION = 1.16;
exports.NULLBYTE = Buffer.from([0]);
;
exports.rand = function () {
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (var i = 0; i < 6; i++)
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    return text;
};
exports.writeManifestUpdate = function (dbPath, manifest) {
    // write manifest to temp
    fs.writeFileSync(path.join(dbPath, "manifest-temp.json"), JSON.stringify(manifest));
    var fd = fs.openSync(path.join(dbPath, "manifest-temp.json"), "rs+");
    fs.fsyncSync(fd);
    fs.closeSync(fd);
    // write to actual file
    fs.writeFileSync(path.join(dbPath, "manifest.json"), JSON.stringify(manifest));
    var fd2 = fs.openSync(path.join(dbPath, "manifest.json"), "rs+");
    fs.fsyncSync(fd2);
    fs.closeSync(fd2);
    // remove temp
    fs.unlinkSync(path.join(dbPath, "manifest-temp.json"));
};
exports.fileName = function (idx) {
    if (String(idx).length > 9) {
        return String(idx);
    }
    return ("000000000" + idx).slice(-9);
};
exports.throttle = function (scope, func, limit) {
    var waiting = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (waiting)
            return;
        waiting = true;
        setTimeout(function () {
            func.apply(scope, args);
            waiting = false;
        }, limit);
    };
};
exports.tableGenerator = function (level, manifest, dbPath, index, done) {
    var it = index.begin();
    var writeNextFile = function () {
        var nextFile = manifest.inc + 1;
        try {
            // remove possible partial files from previous run
            fs.unlinkSync(path.join(dbPath, exports.fileName(nextFile) + ".idx"));
            fs.unlinkSync(path.join(dbPath, exports.fileName(nextFile) + ".dta"));
            fs.unlinkSync(path.join(dbPath, exports.fileName(nextFile) + ".bom"));
        }
        catch (e) {
            // no need to catch this error or care about it, happens if files don't exist.
        }
        var dataLen = 0;
        var totalLen = 0;
        var dataHash = new lib_sha1_1.Sha1();
        var indexJSON = {
            keys: {},
            hash: ""
        };
        var keys = [];
        var firstKey = undefined;
        var lastKey = undefined;
        var nextKey = it.key();
        var levelFileDta = -1;
        var levelFileIdx = -1;
        var levelFileBloom = -1;
        var closeFile = function () {
            if (keys.length) {
                var bloom_1 = lib_bloom_1.BloomFilter.create(keys.length, 0.1);
                var k = keys.length;
                while (k--) {
                    bloom_1.insert(keys[k]);
                }
                fs.fsyncSync(levelFileDta);
                var fd = fs.createReadStream(path.join(dbPath, exports.fileName(nextFile) + ".dta"));
                fd.on("data", function (chunk) {
                    dataHash.update(chunk.toString("utf-8"));
                }).on('end', function () {
                    // checksums for integrity
                    fs.writeSync(levelFileDta, exports.NULLBYTE);
                    fs.writeSync(levelFileDta, exports.NULLBYTE);
                    fs.writeSync(levelFileDta, dataHash.hex());
                    indexJSON.hash = String(lib_bloom_1.MurmurHash3(0, JSON.stringify(indexJSON.keys)));
                    fs.writeSync(levelFileIdx, JSON.stringify(indexJSON));
                    fs.writeSync(levelFileBloom, JSON.stringify(bloom_1.toObject()));
                    // flush to disk
                    fs.fsyncSync(levelFileDta);
                    fs.fsyncSync(levelFileIdx);
                    fs.fsyncSync(levelFileBloom);
                    fs.closeSync(levelFileDta);
                    fs.closeSync(levelFileIdx);
                    fs.closeSync(levelFileBloom);
                    // update manifest
                    if (!manifest.lvl[level]) {
                        manifest.lvl[level] = {
                            comp: 0,
                            files: []
                        };
                    }
                    manifest.lvl[level].files.push({ i: nextFile, range: [firstKey, lastKey] });
                    manifest.inc = nextFile;
                    writeNextFile();
                });
            }
            else {
                done();
            }
        };
        var getNextKey = function () {
            // split files at 2 megabytes
            if (it.valid() && totalLen < 2000000) {
                if (levelFileDta === -1) {
                    levelFileDta = fs.openSync(path.join(dbPath, exports.fileName(nextFile) + ".dta"), "a+");
                    levelFileIdx = fs.openSync(path.join(dbPath, exports.fileName(nextFile) + ".idx"), "a+");
                    levelFileBloom = fs.openSync(path.join(dbPath, exports.fileName(nextFile) + ".bom"), "a+");
                }
                if (firstKey === undefined) {
                    firstKey = nextKey;
                }
                lastKey = nextKey;
                var strKey_1 = String(nextKey);
                keys.push(strKey_1);
                var data = it.value();
                if (data === exports.NULLBYTE) { // tombstone
                    // write index
                    indexJSON.keys[nextKey] = [-1, 0]; // tombstone
                    totalLen += strKey_1.length;
                    it.next();
                    nextKey = it.key();
                    keys.length % 250 === 0 ? setTimeout(getNextKey, 0) : getNextKey();
                }
                else if (typeof data !== "string" && !Buffer.isBuffer(data) && data.fileID) { // file location
                    var dataStart = data.offset[0];
                    var dataLength_1 = data.offset[1];
                    var readFile = fs.createReadStream(path.join(dbPath, data.fileID === -1 ? "LOG" : exports.fileName(data.fileID) + ".dta"), { start: dataStart, end: dataStart + dataLength_1, autoClose: true });
                    var writeFile = fs.createWriteStream(path.join(dbPath, exports.fileName(nextFile) + ".dta"), { fd: levelFileDta, autoClose: false });
                    readFile.pipe(writeFile).on("finish", function () {
                        // write index
                        indexJSON.keys[nextKey] = [dataLen, dataLength_1];
                        dataLen += dataLength_1;
                        totalLen += strKey_1.length + dataLength_1;
                        it.next();
                        nextKey = it.key();
                        keys.length % 250 === 0 ? setTimeout(getNextKey, 0) : getNextKey();
                    }).on("error", function (err) {
                        console.error("FLUSH OR COMPACTION ERROR");
                        console.error(err);
                    });
                }
                else if (typeof data === "string") { // actual data is in index
                    // write index
                    indexJSON.keys[nextKey] = [dataLen, data.length];
                    // write data
                    fs.writeSync(levelFileDta, data);
                    dataHash.update(data);
                    dataLen += data.length;
                    totalLen += strKey_1.length + data.length;
                    it.next();
                    nextKey = it.key();
                    keys.length % 250 === 0 ? setTimeout(getNextKey, 0) : getNextKey();
                }
                else {
                    it.next();
                    nextKey = it.key();
                    keys.length % 250 === 0 ? setTimeout(getNextKey, 0) : getNextKey();
                }
            }
            else {
                if (keys.length) {
                    closeFile();
                }
                else {
                    done();
                }
            }
        };
        getNextKey();
    };
    writeNextFile();
};
//# sourceMappingURL=common.js.map