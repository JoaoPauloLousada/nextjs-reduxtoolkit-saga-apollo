var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var child_process_1 = require("child_process");
var common_1 = require("./common");
var lib_rse_1 = require("./lib_rse");
var fs = require("fs");
var database_1 = require("./database");
var stream = require("stream");
var messageBuffer = {};
var SnapDB = /** @class */ (function () {
    /**
     *Creates an instance of SnapDB.
     * @param {({
     *         dir: string,
     *         key: "string" | "float" | "int" | "any",
     *         cache?: boolean,
     *         autoFlush?: number|boolean,
     *         singleThread?: boolean
     *     })} args
     * @memberof SnapDB
     */
    function SnapDB(args, keyType, cache) {
        var _this = this;
        this.version = common_1.VERSION;
        /**
         * `true` if the database is currently compacting, `false` otherwise.
         * READ ONLY
         *
         * @type {boolean}
         * @memberof SnapDB
         */
        this.isCompacting = false;
        /**
         * `true` if there is an active, open transaction, `false` otherwise.
         * READ ONLY
         *
         * @type {boolean}
         * @memberof SnapDB
         */
        this.isTx = false;
        /**
         * Internal, do not touch!
         *
         * @type {number[]}
         * @memberof SnapDB
         */
        this._clearCompactFiles = [];
        this._hasEvents = false;
        this._autoFlush = true;
        this._onCompactorMessage = this._onCompactorMessage.bind(this);
        if (typeof args === "string") {
            this._path = args;
            this.keyType = keyType || "any";
            this.memoryCache = cache || false;
            this._worker = child_process_1.fork(path.join(__dirname, "database.js"));
        }
        else {
            this._path = path.resolve(args.dir);
            this.keyType = args.key || "any";
            this.memoryCache = args.cache || false;
            this._autoFlush = typeof args.autoFlush === "undefined" ? true : args.autoFlush;
            if (args.mainThread) {
                this._database = new database_1.SnapDatabase(this._path, this.keyType, this.memoryCache, this._autoFlush, false);
            }
            else {
                this._worker = child_process_1.fork(path.join(__dirname, "database.js"));
            }
        }
        this._rse = new lib_rse_1.ReallySmallEvents();
        this._compactor = child_process_1.fork(path.join(__dirname, "compact.js"));
        this._clearCompactFiles = [];
        if (this._worker) { // multi threaded mode
            this._worker.on("message", function (msg) {
                switch (msg.type) {
                    case "snap-ready":
                        _this._isReady = true;
                        break;
                    case "snap-compact":
                        _this.isCompacting = true;
                        _this._compactor.send("do-compact");
                        if (_this._hasEvents)
                            _this._rse.trigger("compact-start", { target: _this, time: Date.now() });
                        break;
                    case "snap-compact-done":
                        _this._cleanupCompaction();
                        break;
                    case "snap-res":
                        if (msg.event && _this._hasEvents) {
                            _this._rse.trigger(msg.event, { target: _this, tx: msg.id, time: Date.now(), data: msg.data[1], error: msg.data[0] });
                        }
                        messageBuffer[msg.id].apply(null, [msg.data]);
                        break;
                    case "snap-res-done":
                        if (msg.event && _this._hasEvents) {
                            _this._rse.trigger(msg.event, { target: _this, tx: msg.id, time: Date.now(), data: msg.data[1], error: msg.data[0] });
                        }
                        if (msg.event === "tx-start") {
                            _this.isTx = true;
                        }
                        if (msg.event === "tx-end") {
                            _this.isTx = false;
                        }
                        messageBuffer[msg.id].apply(null, [msg.data]);
                        delete messageBuffer[msg.id];
                        break;
                    case "snap-clear-done":
                        _this._compactor = child_process_1.fork(path.join(__dirname, "compact.js"));
                        _this._compactor.on("message", _this._onCompactorMessage);
                        messageBuffer[msg.id].apply(null, [msg.data]);
                        delete messageBuffer[msg.id];
                        _this._isReady = true;
                        if (_this._hasEvents)
                            _this._rse.trigger("clear", { target: _this, tx: msg.id, time: Date.now() });
                        break;
                    case "snap-close-done":
                        _this._isReady = false;
                        _this._compactor.kill();
                        _this._worker.kill();
                        messageBuffer[msg.id].apply(null, [msg.data]);
                        delete messageBuffer[msg.id];
                        if (_this._hasEvents)
                            _this._rse.trigger("close", { target: _this, tx: msg.id, time: Date.now() });
                        break;
                }
            });
            this._worker.send({ type: "snap-connect", path: this._path, cache: this.memoryCache, keyType: this.keyType, autoFlush: this._autoFlush });
        }
        // trigger database ready
        var checkReady = function () {
            if (_this._isClosed)
                return;
            if ((_this._database && _this._database.ready) || _this._isReady) {
                _this._isReady = true;
                if (_this._hasEvents) {
                    _this._rse.trigger("ready", { target: _this, time: Date.now() });
                }
            }
            else {
                setTimeout(checkReady, 100);
            }
        };
        checkReady();
        // prepare compactor thread
        this._compactor.on("message", this._onCompactorMessage);
        this._compactor.send({ type: "snap-compact", path: this._path, cache: this.memoryCache, keyType: this.keyType, autoFlush: this._autoFlush });
    }
    /**
     * Listen for events
     *
     * @param {string} event
     * @param {() => void} callback
     * @memberof SnapDB
     */
    SnapDB.prototype.on = function (event, callback) {
        this._hasEvents = true;
        this._rse.on(event, callback);
    };
    /**
     * Turn off listener for events
     *
     * @param {string} event
     * @param {() => void} callback
     * @memberof SnapDB
     */
    SnapDB.prototype.off = function (event, callback) {
        this._rse.off(event, callback);
    };
    /**
     * Forces the log to be flushed to disk files, possibly causing a compaction.
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    SnapDB.prototype.flushLog = function (callback) {
        var _this = this;
        return this._doWhenReady(function (res, rej) {
            if (_this.isCompacting === true) {
                if (callback)
                    callback("Already compacting!");
                rej("Already compacting!");
                return;
            }
            _this.isCompacting = true;
            if (_this._worker) {
                _this._worker.send({ type: "do-compact" });
            }
            else {
                _this._database.maybeFlushLog(true);
                _this._compactor.send("do-compact");
            }
            var checkDone = function () {
                if (_this.isClosed)
                    return;
                if (_this.isCompacting) {
                    setTimeout(checkDone, 100);
                }
                else {
                    if (callback)
                        callback(undefined);
                    res();
                }
            };
            checkDone();
        });
    };
    /**
     * Returns `true` if the database is ready, `false` otherwise.
     *
     * @returns {boolean}
     * @memberof SnapDB
     */
    SnapDB.prototype.isOpen = function () {
        if (this._isReady)
            return true;
        return false;
    };
    /**
     * Returns `true` if the database isn't ready, `false` otherwise.
     *
     * @returns {boolean}
     * @memberof SnapDB
     */
    SnapDB.prototype.isClosed = function () {
        if (this._isReady)
            return false;
        return true;
    };
    /**
     * This resolves when the database is ready to use.
     *
     * @returns {Promise<void>}
     * @memberof SnapDB
     */
    SnapDB.prototype.ready = function (callback) {
        var _this = this;
        if (this._isReady) {
            if (callback)
                callback();
            return Promise.resolve();
        }
        return new Promise(function (res, rej) {
            var readyCB = function () {
                if (callback)
                    callback();
                _this.off("ready", readyCB);
                res();
            };
            _this.on("ready", readyCB);
        });
    };
    /**
     * Get a value from the database given it's key.
     *
     * @param {K} key
     * @returns {Promise<string>}
     * @memberof SnapDB
     */
    SnapDB.prototype.get = function (key, callback) {
        var _this = this;
        var getKey = this.keyType === "any" ? this._anyKey(key) : key;
        return this._doWhenReady(function (res, rej) {
            if (_this._worker) {
                var msgId = _this._msgID(function (data) {
                    if (data[0]) {
                        rej(data[0]);
                    }
                    else {
                        res(data[1] === null ? undefined : data[1]);
                    }
                    if (callback)
                        callback(data[0], data[1] === null ? undefined : data[1]);
                });
                _this._worker.send({ type: "snap-get", key: getKey, id: msgId });
            }
            else {
                try {
                    var data = _this._database.get(getKey);
                    res(data === null ? undefined : data);
                    if (callback)
                        callback(undefined, data === null ? undefined : data);
                    if (_this._hasEvents)
                        _this._rse.trigger("get", { target: _this, tx: common_1.rand(), time: Date.now(), data: data });
                }
                catch (e) {
                    rej(e);
                    if (callback)
                        callback(e);
                    if (_this._hasEvents)
                        _this._rse.trigger("get", { target: _this, tx: common_1.rand(), time: Date.now(), error: e });
                }
            }
        });
    };
    /**
     * Delete a key and it's value from the data store.
     *
     * @param {K} key
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    SnapDB.prototype.delete = function (key, callback) {
        var _this = this;
        if (key === null || key === undefined) {
            if (callback)
                callback("Write Error: Key can't be null or undefined!");
            return Promise.reject("Write Error: Key can't be null or undefined!");
        }
        var getKey = this.keyType === "any" ? this._anyKey(key) : key;
        return this._doWhenReady(function (res, rej) {
            if (_this._worker) {
                var msgId = _this._msgID(function (data) {
                    if (data[0]) {
                        rej(data[0]);
                    }
                    else {
                        res(data[1]);
                    }
                    if (callback)
                        callback(data[0], data[1]);
                });
                _this._worker.send({ type: "snap-del", key: getKey, id: msgId });
            }
            else {
                var msgId = common_1.rand();
                try {
                    res(_this._database.delete(getKey));
                    if (callback)
                        callback(undefined, getKey);
                    if (_this._hasEvents)
                        _this._rse.trigger("delete", { target: _this, tx: msgId, time: Date.now(), data: true });
                }
                catch (e) {
                    rej(e);
                    if (callback)
                        callback(e);
                    if (_this._hasEvents)
                        _this._rse.trigger("delete", { target: _this, tx: msgId, time: Date.now(), error: e });
                }
            }
        });
    };
    /**
     * Delete a key and it's value from the data store.
     *
     * @param {K} key
     * @param {(err: any) => void} [callback]
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    SnapDB.prototype.del = function (key, callback) {
        return this.delete(key, callback);
    };
    /**
     * Put a key and value into the data store.
     * Replaces existing values with new values at the given key, otherwise creates a new key.
     *
     * @param {K} key
     * @param {string} data
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    SnapDB.prototype.put = function (key, data, callback) {
        var _this = this;
        if (key === null || key === undefined) {
            if (callback)
                callback("Write Error: Key can't be null or undefined!", undefined);
            return Promise.reject("Write Error: Key can't be null or undefined!");
        }
        if (data === null || data === undefined || typeof data !== "string") {
            if (callback)
                callback("Write Error: Data must be a string!", undefined);
            return Promise.reject("Write Error: Data must be a string!");
        }
        var parseKey = {
            "string": function (k) { return String(k); },
            "float": function (k) { return isNaN(k) || k === null ? 0 : parseFloat(k); },
            "int": function (k) { return isNaN(k) || k === null ? 0 : parseInt(k); }
        };
        return this._doWhenReady(function (res, rej) {
            if (_this._worker) {
                var msgId = _this._msgID(function (data) {
                    if (data[0]) {
                        rej(data[0]);
                    }
                    else {
                        res(data[1]);
                    }
                    if (callback)
                        callback(data[0], data[1]);
                });
                _this._worker.send({ type: "snap-put", key: _this.keyType === "any" ? _this._anyKey(key) : parseKey[_this.keyType](key), value: data, id: msgId });
            }
            else {
                var msgId = common_1.rand();
                try {
                    var put = _this._database.put(_this.keyType === "any" ? _this._anyKey(key) : parseKey[_this.keyType](key), data);
                    res(put);
                    if (callback)
                        callback(undefined, put);
                    if (_this._hasEvents)
                        _this._rse.trigger("put", { target: _this, tx: msgId, time: Date.now(), data: put });
                }
                catch (e) {
                    rej(e);
                    if (callback)
                        callback(e, undefined);
                    if (_this._hasEvents)
                        _this._rse.trigger("put", { target: _this, tx: msgId, time: Date.now(), error: e });
                }
            }
        });
    };
    /**
     * API compatible version of batch query from LevelDB.
     *
     * @param {({type: "del"|"put", key: K, value?: string}[])} [ops]
     * @param {(error: any) => void} [callback]
     * @returns {*}
     * @memberof SnapDB
     */
    SnapDB.prototype.batch = function (ops, callback) {
        var _this = this;
        if (ops) {
            return new Promise(function (res, rej) {
                var run = function () { return __awaiter(_this, void 0, void 0, function () {
                    var _i, ops_1, action, _a, e_1;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _b.trys.push([0, 10, , 11]);
                                return [4 /*yield*/, this.startTx()];
                            case 1:
                                _b.sent();
                                _i = 0, ops_1 = ops;
                                _b.label = 2;
                            case 2:
                                if (!(_i < ops_1.length)) return [3 /*break*/, 8];
                                action = ops_1[_i];
                                _a = action.type;
                                switch (_a) {
                                    case "del": return [3 /*break*/, 3];
                                    case "put": return [3 /*break*/, 5];
                                }
                                return [3 /*break*/, 7];
                            case 3: return [4 /*yield*/, this.del(action.key)];
                            case 4:
                                _b.sent();
                                return [3 /*break*/, 7];
                            case 5: return [4 /*yield*/, this.put(action.key, action.value || "")];
                            case 6:
                                _b.sent();
                                return [3 /*break*/, 7];
                            case 7:
                                _i++;
                                return [3 /*break*/, 2];
                            case 8: return [4 /*yield*/, this.endTx()];
                            case 9:
                                _b.sent();
                                if (callback)
                                    callback(undefined);
                                res();
                                return [3 /*break*/, 11];
                            case 10:
                                e_1 = _b.sent();
                                if (callback)
                                    callback(e_1);
                                rej(e_1);
                                return [3 /*break*/, 11];
                            case 11: return [2 /*return*/];
                        }
                    });
                }); };
                var check = function () {
                    if (_this._isClosed)
                        return;
                    if (_this.isTx) {
                        setTimeout(check, 100);
                    }
                    else {
                        run();
                    }
                };
                check();
            });
        }
        else {
            var ops_2 = [];
            var chain_1 = {
                length: 0,
                write: function (callback) {
                    return _this.batch(ops_2, callback);
                },
                del: function (key) {
                    ops_2.push({ type: "del", key: key });
                    chain_1.length = ops_2.length;
                    return chain_1;
                },
                put: function (key, value) {
                    ops_2.push({ type: "put", key: key, value: value });
                    chain_1.length = ops_2.length;
                    return chain_1;
                },
                clear: function () {
                    ops_2 = [];
                    chain_1.length = 0;
                    return chain_1;
                }
            };
            return chain_1;
        }
    };
    SnapDB.prototype._levelResultMutate = function (args) {
        return function (key, value) {
            if (args.values === false && args.keys === false)
                return {};
            if (args.values === false)
                return key;
            if (args.keys === false)
                return value;
            return { key: key, value: value };
        };
    };
    /**
     * LevelDB compatible createReadStream function.
     *
     * @param {QueryArgs<K>} args
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    SnapDB.prototype.createReadStream = function (args) {
        return this._streamKeysAndValues(args, "read-stream", "read-stream-end", this._levelResultMutate(args));
    };
    /**
     * LevelDB compatible createKeyStream function.
     *
     * @param {QueryArgs<K>} args
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    SnapDB.prototype.createKeyStream = function (args) {
        var opts = __assign({}, args, { values: false });
        return this._streamKeysAndValues(opts, "read-key-stream", "read-key-stream-end", this._levelResultMutate(opts));
    };
    /**
     * LevelDB compatible createValueStream function.
     *
     * @param {QueryArgs<K>} args
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    SnapDB.prototype.createValueStream = function (args) {
        var opts = __assign({}, args, { keys: false });
        return this._streamKeysAndValues(opts, "read-value-stream", "read-value-stream-end", this._levelResultMutate(opts));
    };
    /**
     * Get all keys from the data store in order, or optionally in reverse order.
     *
     * @param {(key: K) => void} onRecord
     * @param {(err?: any) => void} onComplete
     * @param {boolean} [reverse]
     * @memberof SnapDB
     */
    SnapDB.prototype.getAllKeys = function (onRecord, onComplete, reverse) {
        this._standardKeysAndValues({ reverse: reverse, values: false }, "get-keys", "get-keys-end", onRecord, onComplete);
    };
    /**
     * Get all keys from the data store in order, or optionally in reverse order.
     *
     * @param {boolean} [reverse]
     * @returns {Promise<AsyncIterableIterator<K>>}
     * @memberof SnapDB
     */
    SnapDB.prototype.getAllKeysIt = function (reverse) {
        return this._iterateKeysAndValues({ reverse: reverse, values: false }, "get-keys", "get-keys-end", true);
    };
    /**
     *
     *
     * @param {boolean} [reverse]
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    SnapDB.prototype.getAllKeysStream = function (reverse) {
        return this._streamKeysAndValues({ reverse: reverse, values: false }, "get-keys", "get-keys-end", function (key, value) { return key; });
    };
    /**
     * Get the total number of keys in the data store.
     *
     * @returns {Promise<number>}
     * @memberof SnapDB
     */
    SnapDB.prototype.getCount = function (callback) {
        var _this = this;
        return this._doWhenReady(function (res, rej) {
            if (_this._worker) {
                var msgId = _this._msgID(function (data) {
                    if (data[0]) {
                        rej(data[0]);
                    }
                    else {
                        res(parseInt(data[1]));
                    }
                    if (callback)
                        callback(data[0], data[1] !== undefined ? parseInt(data[1]) : undefined);
                });
                _this._worker.send({ type: "snap-count", id: msgId });
            }
            else {
                var msgId = common_1.rand();
                try {
                    var ct = _this._database.getCount();
                    res(ct);
                    if (callback)
                        callback(undefined, ct);
                    if (_this._hasEvents)
                        _this._rse.trigger("get-count", { target: _this, tx: msgId, time: Date.now(), data: ct });
                }
                catch (e) {
                    rej(e);
                    if (callback)
                        callback(e);
                    if (_this._hasEvents)
                        _this._rse.trigger("get-count", { target: _this, tx: msgId, time: Date.now(), error: e });
                }
            }
        });
    };
    /**
     * Get all keys and values from the store in order, or optionally in reverse order.
     *
     * @param {(key: K, data: string) => void} onRecord
     * @param {(err?: any) => void} onComplete
     * @param {boolean} [reverse]
     * @memberof SnapDB
     */
    SnapDB.prototype.getAll = function (onRecord, onComplete, reverse) {
        this._standardKeysAndValues({ reverse: reverse }, "get-all", "get-all-end", onRecord, onComplete);
    };
    /**
     * Get all keys and values from the store in order, or optionally in reverse order.
     *
     * @param {boolean} [reverse]
     * @returns {Promise<AsyncIterableIterator<[K, string]>>}
     * @memberof SnapDB
     */
    SnapDB.prototype.getAllIt = function (reverse) {
        return this._iterateKeysAndValues({ reverse: reverse }, "get-all", "get-all-end");
    };
    /**
     * Get all keys and values from the store in order, or optionally in reverse order.
     *
     * @param {boolean} [reverse]
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    SnapDB.prototype.getAllStream = function (reverse) {
        return this._streamKeysAndValues({ reverse: reverse }, "get-all", "get-all-end");
    };
    /**
     * Gets the keys and values between a given range, inclusive.  Optionally get the range in reverse order.
     *
     * @param {K} lower
     * @param {K} higher
     * @param {(key: K, data: string) => void} onRecord
     * @param {(err?: any) => void} onComplete
     * @param {boolean} [reverse]
     * @memberof SnapDB
     */
    SnapDB.prototype.range = function (lower, higher, onRecord, onComplete, reverse) {
        this._standardKeysAndValues(reverse ? { lte: higher, gt: lower, reverse: true } : { lt: higher, gte: lower }, "get-range", "get-range-end", onRecord, onComplete);
    };
    /**
     * Gets the keys and values between a given range, inclusive.  Optionally get the range in reverse order.
     *
     * @param {boolean} [reverse]
     * @returns {Promise<AsyncIterableIterator<[K, string]>>}
     * @memberof SnapDB
     */
    SnapDB.prototype.rangeIt = function (lower, higher, reverse) {
        return this._iterateKeysAndValues(reverse ? { lte: higher, gt: lower, reverse: true } : { lt: higher, gte: lower }, "get-range", "get-range-end");
    };
    /**
     * Gets the keys and values between a given range, inclusive.  Optionally get the range in reverse order.
     *
     * @param {K} lower
     * @param {K} higher
     * @param {boolean} [reverse]
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    SnapDB.prototype.rangeStream = function (lower, higher, reverse) {
        return this._streamKeysAndValues(reverse ? { lte: higher, gt: lower, reverse: true } : { lt: higher, gte: lower }, "get-range", "get-range-end");
    };
    /**
     * Get a collection of values from the keys at the given offset/limit. Optionally get the results from the end of the key set.
     *
     * @param {number} offset
     * @param {number} limit
     * @param {(key: K, data: string) => void} onRecord
     * @param {(err?: any) => void} onComplete
     * @param {boolean} [reverse]
     * @memberof SnapDB
     */
    SnapDB.prototype.offset = function (offset, limit, onRecord, onComplete, reverse) {
        this._standardKeysAndValues({ offset: offset, limit: limit, reverse: reverse }, "get-offset", "get-offset-end", onRecord, onComplete);
    };
    /**
     * Get a collection of values from the keys at the given offset/limit. Optionally get the results from the end of the key set.
     *
     * @param {boolean} [reverse]
     * @returns {Promise<AsyncIterableIterator<[K, string]>>}
     * @memberof SnapDB
     */
    SnapDB.prototype.offsetIt = function (offset, limit, reverse) {
        return this._iterateKeysAndValues({ offset: offset, limit: limit, reverse: reverse }, "get-offset", "get-offset-end");
    };
    /**
     * Get a collection of values from the keys at the given offset/limit. Optionally get the results from the end of the key set.
     *
     * @param {number} offset
     * @param {number} limit
     * @param {boolean} [reverse]
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    SnapDB.prototype.offsetStream = function (offset, limit, reverse) {
        return this._streamKeysAndValues({ offset: offset, limit: limit, reverse: reverse }, "get-offset", "get-offset-end");
    };
    /**
     * Standard query for data
     *
     * @param {QueryArgs<K>} args
     * @param {((key: K, data: string|undefined) => void)} onRecord
     * @param {(err?: any) => void} onComplete
     * @memberof SnapDB
     */
    SnapDB.prototype.query = function (args, onRecord, onComplete) {
        this._standardKeysAndValues(args, "get-query", "get-query-end", onRecord, onComplete);
    };
    /**
     * Get a collection of values from the keys at the given offset/limit. Optionally get the results from the end of the key set.
     *
     * @param {boolean} [reverse]
     * @returns {Promise<AsyncIterableIterator<[K, string]>>}
     * @memberof SnapDB
     */
    SnapDB.prototype.queryIt = function (args) {
        return this._iterateKeysAndValues(args, "get-query", "get-query-end");
    };
    /**
     * Get a collection of values from the keys at the given offset/limit. Optionally get the results from the end of the key set.
     *
     * @param {QueryArgs<K>} args
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    SnapDB.prototype.queryStream = function (args) {
        return this._streamKeysAndValues(args, "get-query", "get-query-end");
    };
    /**
     * Check if a key exists or not.
     *
     * @param {K} key
     * @param {(err: any, exists: boolean) => void} [callback]
     * @returns {Promise<boolean>}
     * @memberof SnapDB
     */
    SnapDB.prototype.exists = function (key, callback) {
        var _this = this;
        var getKey = this.keyType === "any" ? this._anyKey(key) : key;
        return this._doWhenReady(function (res, rej) {
            if (_this._worker) {
                var msgId = _this._msgID(function (data) {
                    if (data[0]) {
                        rej(data[0]);
                    }
                    else {
                        res(data[1]);
                    }
                    if (callback)
                        callback(data[0], data[1]);
                });
                _this._worker.send({ type: "snap-exists", key: getKey, id: msgId });
            }
            else {
                try {
                    var data = _this._database.exists(getKey);
                    res(data);
                    if (callback)
                        callback(undefined, data);
                    if (_this._hasEvents)
                        _this._rse.trigger("exists", { target: _this, tx: common_1.rand(), time: Date.now(), data: data });
                }
                catch (e) {
                    rej(e);
                    if (callback)
                        callback(e);
                    if (_this._hasEvents)
                        _this._rse.trigger("exists", { target: _this, tx: common_1.rand(), time: Date.now(), error: e });
                }
            }
        });
    };
    /**
     * Begins a transaction.
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    SnapDB.prototype.startTx = function (callback) {
        var _this = this;
        return this._doWhenReady(function (res, rej) {
            if (_this._worker) {
                var msgId = _this._msgID(function (data) {
                    if (data[0]) {
                        rej(data[0]);
                    }
                    else {
                        res();
                    }
                    if (callback)
                        callback(data[0], data[1]);
                });
                _this._worker.send({ type: "snap-start-tx", id: msgId });
            }
            else {
                try {
                    _this._database.startTX();
                    res(_this._database.txNum);
                    if (callback)
                        callback(undefined, _this._database.txNum);
                    if (_this._hasEvents)
                        _this._rse.trigger("tx-start", { target: _this, tx: _this._database.txNum, time: Date.now(), data: _this._database.txNum });
                    _this.isTx = true;
                }
                catch (e) {
                    rej(e);
                    if (callback)
                        callback(e);
                    if (_this._hasEvents)
                        _this._rse.trigger("tx-start", { target: _this, tx: undefined, time: Date.now(), error: e });
                }
            }
        });
    };
    /**
     * Starts a transaction. (depreciated method, use .startTx() instead)
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    SnapDB.prototype.begin_transaction = function () {
        return this.startTx();
    };
    /**
     * Ends a transaction
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    SnapDB.prototype.endTx = function (callback) {
        var _this = this;
        return this._doWhenReady(function (res, rej) {
            if (_this._worker) {
                var msgId = _this._msgID(function (data) {
                    if (data[0]) {
                        rej(data[0]);
                    }
                    else {
                        res();
                    }
                    if (callback)
                        callback(data[0], data[1]);
                });
                _this._worker.send({ type: "snap-end-tx", id: msgId });
            }
            else {
                try {
                    var currentTX = _this._database.txNum;
                    _this._database.endTX();
                    if (_this._hasEvents)
                        _this._rse.trigger("tx-end", { target: _this, tx: currentTX, time: Date.now(), data: currentTX });
                    res(currentTX);
                    if (callback)
                        callback(undefined, currentTX);
                    _this.isTx = false;
                }
                catch (e) {
                    rej(e);
                    if (callback)
                        callback(e);
                    if (_this._hasEvents)
                        _this._rse.trigger("tx-end", { target: _this, tx: _this._database.txNum, time: Date.now(), error: e });
                }
            }
        });
    };
    /**
     * Ends a transaction. (depreciated method, use .endTx() instead)
     *
     * @returns
     * @memberof SnapDB
     */
    SnapDB.prototype.end_transaction = function () {
        return this.endTx();
    };
    /**
     * Closes database.  This isn't reversible, you must create a new SnapDB instance if you want to reconnect to this database without restarting your app.
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    SnapDB.prototype.close = function (callback) {
        var _this = this;
        if (this._isClosed) {
            if (callback)
                callback();
            return Promise.resolve();
        }
        this._isClosed = true;
        return new Promise(function (res, rej) {
            if (_this._worker) {
                var msgId = _this._msgID(function (data) {
                    _this._worker.kill();
                    _this._isReady = false;
                    if (data[0]) {
                        if (callback)
                            callback(data[0]);
                        rej(data[0]);
                    }
                    else {
                        if (callback)
                            callback();
                        res();
                    }
                });
                _this._worker.send({ type: "snap-close", id: msgId });
            }
            else {
                try {
                    _this._isReady = false;
                    _this._compactor.kill();
                    res(_this._database.close());
                    if (callback)
                        callback();
                    if (_this._hasEvents)
                        _this._rse.trigger("close", { target: _this, tx: common_1.rand(), time: Date.now() });
                }
                catch (e) {
                    if (callback)
                        callback(e);
                    rej(e);
                }
            }
        });
    };
    /**
     * Empty all keys and values from database.
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    SnapDB.prototype.empty = function (callback) {
        var _this = this;
        return new Promise(function (res, rej) {
            if (!_this._isReady) {
                if (callback)
                    callback(undefined);
                res();
                return;
            }
            _this._isReady = false;
            // kill compactor thread (don't care what it's doing)
            _this._compactor.kill();
            if (_this._worker) {
                var msgId = _this._msgID(function (data) {
                    if (data[0]) {
                        rej(data[0]);
                    }
                    else {
                        res();
                    }
                    if (callback)
                        callback(data[0]);
                });
                _this._worker.send({ type: "snap-clear", id: msgId });
            }
            else {
                var msgId = common_1.rand();
                _this._database.clear();
                // spin up new compactor thread
                _this._compactor = child_process_1.fork(path.join(__dirname, "compact.js"));
                _this._compactor.on("message", _this._onCompactorMessage);
                _this._compactor.send({ type: "snap-compact", path: _this._path, cache: _this.memoryCache, keyType: _this.keyType, autoFlush: _this._autoFlush });
                _this._isReady = true;
                if (callback)
                    callback(undefined);
                if (_this._hasEvents)
                    _this._rse.trigger("clear", { target: _this, tx: msgId, time: Date.now() });
            }
        });
    };
    /**
     * Perform an async action after the database is ready.  Does the action right away if the database is already ready.
     *
     * @private
     * @param {(cres: (value?: unknown) => void, crej: (value?: unknown) => void) => void} callback
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    SnapDB.prototype._doWhenReady = function (callback) {
        var _this = this;
        return new Promise(function (res, rej) {
            if (_this._isReady) {
                callback(res, rej);
            }
            else {
                var fired_1 = false;
                var cb_1 = function () {
                    if (fired_1)
                        return;
                    fired_1 = true;
                    callback(res, rej);
                    setTimeout(function () {
                        _this.off("ready", cb_1);
                        _this.off("clear", cb_1);
                    }, 100);
                };
                _this.on("ready", cb_1);
                _this.on("clear", cb_1);
            }
        });
    };
    /**
     * Handle messages from the compactor thread.
     *
     * @private
     * @param {*} msg
     * @memberof SnapDB
     */
    SnapDB.prototype._onCompactorMessage = function (msg) {
        if (msg.type === "compact-done") {
            this._clearCompactFiles = msg.files;
            if (this._worker) {
                this._worker.send({ type: "compact-done" });
            }
            else {
                this._database.compactDone();
                this._cleanupCompaction();
            }
        }
    };
    /**
     * Generate a message id and callback for sending messages to the worker thread.
     *
     * @private
     * @param {(data: any) => void} cb
     * @returns
     * @memberof SnapDB
     */
    SnapDB.prototype._msgID = function (cb) {
        var msgId = common_1.rand();
        while (messageBuffer[msgId]) {
            msgId = common_1.rand();
        }
        messageBuffer[msgId] = cb;
        return msgId;
    };
    /**
     * Make "any" type keys are numbers or strings
     *
     * @private
     * @param {*} key
     * @returns {*}
     * @memberof SnapDB
     */
    SnapDB.prototype._anyKey = function (key) {
        var type = typeof key;
        if (type === "string" || type === "number")
            return key;
        return key !== undefined && key.toString && typeof key.toString === "function" ? key.toString() : String(key);
    };
    /**
     * Handle work after compaction is finished.
     *
     * @private
     * @memberof SnapDB
     */
    SnapDB.prototype._cleanupCompaction = function () {
        var _this = this;
        this.isCompacting = false;
        // safe to remove old files now
        this._clearCompactFiles.forEach(function (fileID) {
            try {
                fs.unlinkSync(path.join(_this._path, common_1.fileName(fileID) + ".dta"));
                fs.unlinkSync(path.join(_this._path, common_1.fileName(fileID) + ".idx"));
                fs.unlinkSync(path.join(_this._path, common_1.fileName(fileID) + ".bom"));
            }
            catch (e) {
            }
        });
        this._clearCompactFiles = [];
        if (this._hasEvents)
            this._rse.trigger("compact-end", { target: this, time: Date.now() });
        if (this._compactId && messageBuffer[this._compactId]) {
            messageBuffer[this._compactId].apply(null, [undefined]);
            delete messageBuffer[this._compactId];
            this._compactId = "";
        }
    };
    SnapDB.prototype._streamKeysAndValues = function (args, progressEvent, doneEvent, mutateResult) {
        var s = new stream.Readable();
        this._standardKeysAndValues(args, progressEvent, doneEvent, function (key, value) {
            s.push(mutateResult ? mutateResult(key, value) : [key, value]);
        }, function (err) {
            if (err) {
                s.emit("error", err);
            }
            else {
                s.push(null);
            }
        });
        return s;
    };
    SnapDB.prototype._standardKeysAndValues = function (args, progressEvent, doneEvent, onRecord, onComplete) {
        var _this = this;
        this._doWhenReady(function () {
            var i = 0;
            var queryId = common_1.rand();
            if (_this._worker) {
                _this._asyncNewIterator(args).then(function (id) {
                    var nextRow = function () {
                        _this._asyncNextIterator(id).then(function (value) {
                            if (value.done) {
                                onComplete();
                                if (_this._hasEvents)
                                    _this._rse.trigger(doneEvent, { target: _this, query: args, tx: queryId, time: Date.now(), error: undefined });
                            }
                            else {
                                if (args.values === false) {
                                    if (_this._hasEvents)
                                        _this._rse.trigger(progressEvent, { target: _this, query: args, tx: queryId, time: Date.now(), data: { k: value.key, v: undefined } });
                                    onRecord(args.keys === false ? undefined : value.key, undefined);
                                    i++;
                                    i % 250 ? setImmediate(nextRow) : nextRow();
                                }
                                else {
                                    _this.get(value.key).then(function (val) {
                                        onRecord(args.keys === false ? undefined : value.key, val);
                                        if (_this._hasEvents)
                                            _this._rse.trigger(progressEvent, { target: _this, query: args, tx: queryId, time: Date.now(), data: { k: value.key, v: val } });
                                        i++;
                                        i % 250 ? setImmediate(nextRow) : nextRow();
                                    }).catch(function (error) {
                                        if (_this._hasEvents)
                                            _this._rse.trigger(doneEvent, { target: _this, query: args, tx: queryId, time: Date.now(), error: error });
                                        onComplete(error);
                                    });
                                }
                            }
                        }).catch(function (error) {
                            if (_this._hasEvents)
                                _this._rse.trigger(doneEvent, { target: _this, query: args, tx: queryId, time: Date.now(), error: error });
                            onComplete(error);
                        });
                    };
                    nextRow();
                }).catch(function (error) {
                    if (_this._hasEvents)
                        _this._rse.trigger(doneEvent, { target: _this, query: args, tx: queryId, time: Date.now(), error: error });
                    onComplete(error);
                });
            }
            else {
                try {
                    var id = _this._database.newIterator(args);
                    var nextKey = _this._database.nextIterator(id);
                    while (!nextKey.done) {
                        if (args.values === false) {
                            onRecord(args.keys === false ? undefined : nextKey.key, undefined);
                        }
                        else {
                            onRecord(args.keys === false ? undefined : nextKey.key, _this._database.get(nextKey.key));
                        }
                        nextKey = _this._database.nextIterator(id);
                    }
                    _this._database.clearIterator(id);
                    onComplete();
                    if (_this._hasEvents)
                        _this._rse.trigger(doneEvent, { target: _this, query: args, tx: queryId, time: Date.now(), error: undefined });
                }
                catch (e) {
                    onComplete(e);
                    if (_this._hasEvents)
                        _this._rse.trigger(doneEvent, { target: _this, query: args, tx: queryId, time: Date.now(), error: e });
                }
            }
        });
    };
    /**
     * Generate iterable for database queries.
     *
     * @private
     * @param {("all"|"offset"|"range")} mode
     * @param {any[]} args
     * @param {boolean} reverse
     * @param {string} progressEvent
     * @param {string} doneEvent
     * @returns {Promise<AsyncIterableIterator<[K, string]>>}
     * @memberof SnapDB
     */
    SnapDB.prototype._iterateKeysAndValues = function (args, progressEvent, doneEvent, keysOnly) {
        var _this = this;
        return this._doWhenReady(function (res, rej) {
            var that = _this;
            var loop = function () {
                return __asyncGenerator(this, arguments, function () {
                    var id, nextKey, nextValue, _a, _b, e_2, id, nextKey, nextValue, _c, _d, e_3;
                    return __generator(this, function (_e) {
                        switch (_e.label) {
                            case 0:
                                if (!that._worker) return [3 /*break*/, 18];
                                return [4 /*yield*/, __await(that._asyncNewIterator(args))];
                            case 1:
                                id = _e.sent();
                                _e.label = 2;
                            case 2:
                                _e.trys.push([2, 16, , 17]);
                                return [4 /*yield*/, __await(that._asyncNextIterator(id))];
                            case 3:
                                nextKey = _e.sent();
                                if (!(nextKey.done || args.values === false)) return [3 /*break*/, 4];
                                _a = undefined;
                                return [3 /*break*/, 6];
                            case 4: return [4 /*yield*/, __await(that.get(nextKey.key))];
                            case 5:
                                _a = _e.sent();
                                _e.label = 6;
                            case 6:
                                nextValue = _a;
                                _e.label = 7;
                            case 7:
                                if (!!nextKey.done) return [3 /*break*/, 14];
                                if (that._hasEvents)
                                    that._rse.trigger(progressEvent, { target: that, query: args, tx: id, time: Date.now(), data: { k: nextKey, v: nextValue } });
                                return [4 /*yield*/, __await(keysOnly ? nextKey.key : [args.keys === false ? undefined : nextKey.key, nextValue])];
                            case 8: return [4 /*yield*/, _e.sent()];
                            case 9:
                                _e.sent();
                                return [4 /*yield*/, __await(that._asyncNextIterator(id))];
                            case 10:
                                nextKey = _e.sent();
                                if (!(nextKey.done || args.values === false)) return [3 /*break*/, 11];
                                _b = undefined;
                                return [3 /*break*/, 13];
                            case 11: return [4 /*yield*/, __await(that.get(nextKey.key))];
                            case 12:
                                _b = _e.sent();
                                _e.label = 13;
                            case 13:
                                nextValue = _b;
                                return [3 /*break*/, 7];
                            case 14: return [4 /*yield*/, __await(that._asyncClearIteator(id))];
                            case 15:
                                _e.sent();
                                if (that._hasEvents)
                                    that._rse.trigger(doneEvent, { target: that, query: args, tx: id, time: Date.now(), error: undefined });
                                return [3 /*break*/, 17];
                            case 16:
                                e_2 = _e.sent();
                                if (that._hasEvents)
                                    that._rse.trigger(doneEvent, { target: that, query: args, tx: id, time: Date.now(), error: eval });
                                throw e_2;
                            case 17: return [3 /*break*/, 31];
                            case 18:
                                id = that._database.newIterator(args);
                                _e.label = 19;
                            case 19:
                                _e.trys.push([19, 30, , 31]);
                                nextKey = that._database.nextIterator(id);
                                if (!(nextKey.done || args.values === false)) return [3 /*break*/, 20];
                                _c = undefined;
                                return [3 /*break*/, 22];
                            case 20: return [4 /*yield*/, __await(that.get(nextKey.key))];
                            case 21:
                                _c = _e.sent();
                                _e.label = 22;
                            case 22:
                                nextValue = _c;
                                _e.label = 23;
                            case 23:
                                if (!!nextKey.done) return [3 /*break*/, 29];
                                if (that._hasEvents)
                                    that._rse.trigger(progressEvent, { target: that, query: args, tx: id, time: Date.now(), data: { k: nextKey, v: nextValue } });
                                return [4 /*yield*/, __await(keysOnly ? nextKey.key : [args.keys === false ? undefined : nextKey.key, nextValue])];
                            case 24: return [4 /*yield*/, _e.sent()];
                            case 25:
                                _e.sent();
                                nextKey = that._database.nextIterator(id);
                                if (!(nextKey.done || args.values === false)) return [3 /*break*/, 26];
                                _d = undefined;
                                return [3 /*break*/, 28];
                            case 26: return [4 /*yield*/, __await(that.get(nextKey.key))];
                            case 27:
                                _d = _e.sent();
                                _e.label = 28;
                            case 28:
                                nextValue = _d;
                                return [3 /*break*/, 23];
                            case 29:
                                that._database.clearIterator(id);
                                if (that._hasEvents)
                                    that._rse.trigger(doneEvent, { target: that, query: args, tx: id, time: Date.now(), error: undefined });
                                return [3 /*break*/, 31];
                            case 30:
                                e_3 = _e.sent();
                                if (that._hasEvents)
                                    that._rse.trigger(doneEvent, { target: that, query: args, tx: id, time: Date.now(), error: e_3 });
                                throw e_3;
                            case 31: return [2 /*return*/];
                        }
                    });
                });
            };
            res(loop());
        });
    };
    /**
     * Generate new key iterator in the worker thread.
     *
     * @private
     * @param {("all" | "offset" | "range")} mode
     * @param {any[]} args
     * @param {boolean} reverse
     * @returns {Promise<string>}
     * @memberof SnapDB
     */
    SnapDB.prototype._asyncNewIterator = function (args) {
        var _this = this;
        return new Promise(function (res, rej) {
            var msgId = _this._msgID(function (data) {
                if (data[0]) {
                    rej(data[0]);
                }
                else {
                    res(data[1]);
                }
            });
            _this._worker.send({ type: "snap-new-iterator", args: [args], id: msgId });
        });
    };
    /**
     * Increment the worker thread key iterator.
     *
     * @private
     * @param {string} id
     * @returns {Promise<{ key: K, done: boolean }>}
     * @memberof SnapDB
     */
    SnapDB.prototype._asyncNextIterator = function (id) {
        var _this = this;
        return new Promise(function (res, rej) {
            var msgId = _this._msgID(function (data) {
                if (data[0]) {
                    rej(data[0]);
                }
                else {
                    res(data[1]);
                }
            });
            _this._worker.send({ type: "snap-next-iterator", args: [id], id: msgId });
        });
    };
    /**
     * Clear an iterator from the worker thread.
     *
     * @private
     * @param {string} id
     * @returns {Promise<void>}
     * @memberof SnapDB
     */
    SnapDB.prototype._asyncClearIteator = function (id) {
        var _this = this;
        return new Promise(function (res, rej) {
            var msgId = _this._msgID(function (data) {
                if (data[0]) {
                    rej(data[0]);
                }
                else {
                    res();
                }
            });
            _this._worker.send({ type: "snap-clear-iterator", args: [id], id: msgId });
        });
    };
    return SnapDB;
}());
exports.SnapDB = SnapDB;
/*
function makeid() {
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

    for (var i = 0; i < Math.ceil(Math.random() * 400) + 100; i++)
        text += possible.charAt(Math.floor(Math.random() * possible.length));

    return text;
}


const db = new SnapDB<number>({dir: "my-db-test", key: "int", mainThread: true, autoFlush: false, cache: true});
console.time("READY");
db.ready().then(() => {
    console.timeEnd("READY");

    let arr: any[] = [];
    let count = 100000;
    for (let i = 0; i < count; i++) {
        arr.push([i + 1, makeid(), makeid()]);
    }

    arr = arr.sort((a, b) => Math.random() > 0.5 ? 1 : -1);
    const writeStart = Date.now();
    let last: any;
    const start = Date.now();
    let ct = 0;
    let read = false;
    if (read) {
        db.getAll((key, data) => {
            ct++;
            console.log(key, data);
        }, (err) => {
            if (err) {
                console.log(err);
            }
            const time = (Date.now() - start);
            db.getCount().then((ct) => {
                console.log(ct, "RECORDS");
                console.log(((ct / time) * 1000).toLocaleString(), "Records Per Second (READ)");
                return db.close();
            });
        }, false);
    } else {
        let i = 0;
        db.begin_transaction().then(() => {
            return Promise.all(arr.map(r => db.put(r[0], r[2])))
        }).then(() => {
            return db.end_transaction();
        }).then(() => {
            console.log((count / (Date.now() - writeStart) * 1000).toLocaleString(), "Records Per Second (WRITE)");
            const start = Date.now();
            let ct = 0;
            db.getAll((key, data) => {
                ct++;
                // console.log(key, data);
            }, (err) => {
                if (err) {
                    console.log(err);
                }
                const time = (Date.now() - start);
                db.getCount().then((ct) => {
                    console.log(((ct / time) * 1000).toLocaleString(), "Records Per Second (READ)");
                    // return db.close();
                });
            }, false);
        }).catch((err) => {
            console.trace(err);
        })
    }
});*/ 
//# sourceMappingURL=index.js.map