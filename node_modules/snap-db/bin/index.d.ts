/// <reference types="node" />
import { QueryArgs } from "./common";
import * as stream from "stream";
export interface SnapEvent {
    target: SnapDB<any>;
    time: number;
    [key: string]: any;
}
export declare class SnapDB<K> {
    version: number;
    /**
     * `true` if the database is currently compacting, `false` otherwise.
     * READ ONLY
     *
     * @type {boolean}
     * @memberof SnapDB
     */
    isCompacting: boolean;
    /**
     * `true` if there is an active, open transaction, `false` otherwise.
     * READ ONLY
     *
     * @type {boolean}
     * @memberof SnapDB
     */
    isTx: boolean;
    /**
     * Holds the current key type.
     * READ ONLY
     *
     * @type {("string" | "float" | "int" | "any")}
     * @memberof SnapDB
     */
    keyType: "string" | "float" | "int" | "any";
    /**
     * `true` if the in memory cache is enabled, `false` otherwise.
     * READ ONLY
     *
     * @type {boolean}
     * @memberof SnapDB
     */
    memoryCache?: boolean;
    /**
     * Internal, do not touch!
     *
     * @type {number[]}
     * @memberof SnapDB
     */
    _clearCompactFiles: number[];
    private _isReady;
    private _path;
    private _worker;
    private _compactor;
    private _rse;
    private _hasEvents;
    private _compactId;
    private _database;
    private _autoFlush;
    private _isClosed;
    /**
     *Creates an instance of SnapDB.
     * @param {({
     *         dir: string,
     *         key: "string" | "float" | "int" | "any",
     *         cache?: boolean,
     *         autoFlush?: number|boolean,
     *         singleThread?: boolean
     *     })} args
     * @memberof SnapDB
     */
    constructor(args: {
        dir: string;
        key?: "string" | "float" | "int" | "any";
        cache?: boolean;
        autoFlush?: number | boolean;
        mainThread?: boolean;
    } | string, keyType?: "string" | "float" | "int" | "any", cache?: boolean);
    /**
     * Listen for events
     *
     * @param {string} event
     * @param {() => void} callback
     * @memberof SnapDB
     */
    on(event: string, callback: (event: SnapEvent) => void): void;
    /**
     * Turn off listener for events
     *
     * @param {string} event
     * @param {() => void} callback
     * @memberof SnapDB
     */
    off(event: string, callback: (event: SnapEvent) => void): void;
    /**
     * Forces the log to be flushed to disk files, possibly causing a compaction.
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    flushLog(callback?: (err: any) => void): Promise<any>;
    /**
     * Returns `true` if the database is ready, `false` otherwise.
     *
     * @returns {boolean}
     * @memberof SnapDB
     */
    isOpen(): boolean;
    /**
     * Returns `true` if the database isn't ready, `false` otherwise.
     *
     * @returns {boolean}
     * @memberof SnapDB
     */
    isClosed(): boolean;
    /**
     * This resolves when the database is ready to use.
     *
     * @returns {Promise<void>}
     * @memberof SnapDB
     */
    ready(callback?: () => void): Promise<void>;
    /**
     * Get a value from the database given it's key.
     *
     * @param {K} key
     * @returns {Promise<string>}
     * @memberof SnapDB
     */
    get(key: K, callback?: (err: any, value?: string) => void): Promise<string | undefined>;
    /**
     * Delete a key and it's value from the data store.
     *
     * @param {K} key
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    delete(key: K, callback?: (err: any, key?: K) => void): Promise<any>;
    /**
     * Delete a key and it's value from the data store.
     *
     * @param {K} key
     * @param {(err: any) => void} [callback]
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    del(key: K, callback?: (err: any) => void): Promise<any>;
    /**
     * Put a key and value into the data store.
     * Replaces existing values with new values at the given key, otherwise creates a new key.
     *
     * @param {K} key
     * @param {string} data
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    put(key: K, data: string, callback?: (err: any, response: any) => void): Promise<any>;
    /**
     * API compatible version of batch query from LevelDB.
     *
     * @param {({type: "del"|"put", key: K, value?: string}[])} [ops]
     * @param {(error: any) => void} [callback]
     * @returns {*}
     * @memberof SnapDB
     */
    batch(ops?: {
        type: "del" | "put";
        key: K;
        value?: string;
    }[], callback?: (error: any) => void): any;
    private _levelResultMutate;
    /**
     * LevelDB compatible createReadStream function.
     *
     * @param {QueryArgs<K>} args
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    createReadStream(args: QueryArgs<K>): stream.Readable;
    /**
     * LevelDB compatible createKeyStream function.
     *
     * @param {QueryArgs<K>} args
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    createKeyStream(args: QueryArgs<K>): stream.Readable;
    /**
     * LevelDB compatible createValueStream function.
     *
     * @param {QueryArgs<K>} args
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    createValueStream(args: QueryArgs<K>): stream.Readable;
    /**
     * Get all keys from the data store in order, or optionally in reverse order.
     *
     * @param {(key: K) => void} onRecord
     * @param {(err?: any) => void} onComplete
     * @param {boolean} [reverse]
     * @memberof SnapDB
     */
    getAllKeys(onRecord: (key: K) => void, onComplete: (err?: any) => void, reverse?: boolean): void;
    /**
     * Get all keys from the data store in order, or optionally in reverse order.
     *
     * @param {boolean} [reverse]
     * @returns {Promise<AsyncIterableIterator<K>>}
     * @memberof SnapDB
     */
    getAllKeysIt(reverse?: boolean): Promise<AsyncIterableIterator<K>>;
    /**
     *
     *
     * @param {boolean} [reverse]
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    getAllKeysStream(reverse?: boolean): stream.Readable;
    /**
     * Get the total number of keys in the data store.
     *
     * @returns {Promise<number>}
     * @memberof SnapDB
     */
    getCount(callback?: (err: any, count?: number) => void): Promise<number>;
    /**
     * Get all keys and values from the store in order, or optionally in reverse order.
     *
     * @param {(key: K, data: string) => void} onRecord
     * @param {(err?: any) => void} onComplete
     * @param {boolean} [reverse]
     * @memberof SnapDB
     */
    getAll(onRecord: (key: K, data: string) => void, onComplete: (err?: any) => void, reverse?: boolean): void;
    /**
     * Get all keys and values from the store in order, or optionally in reverse order.
     *
     * @param {boolean} [reverse]
     * @returns {Promise<AsyncIterableIterator<[K, string]>>}
     * @memberof SnapDB
     */
    getAllIt(reverse?: boolean): Promise<AsyncIterableIterator<[K, string]>>;
    /**
     * Get all keys and values from the store in order, or optionally in reverse order.
     *
     * @param {boolean} [reverse]
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    getAllStream(reverse?: boolean): stream.Readable;
    /**
     * Gets the keys and values between a given range, inclusive.  Optionally get the range in reverse order.
     *
     * @param {K} lower
     * @param {K} higher
     * @param {(key: K, data: string) => void} onRecord
     * @param {(err?: any) => void} onComplete
     * @param {boolean} [reverse]
     * @memberof SnapDB
     */
    range(lower: K, higher: K, onRecord: (key: K, data: string) => void, onComplete: (err?: any) => void, reverse?: boolean): void;
    /**
     * Gets the keys and values between a given range, inclusive.  Optionally get the range in reverse order.
     *
     * @param {boolean} [reverse]
     * @returns {Promise<AsyncIterableIterator<[K, string]>>}
     * @memberof SnapDB
     */
    rangeIt(lower: K, higher: K, reverse?: boolean): Promise<AsyncIterableIterator<[K, string]>>;
    /**
     * Gets the keys and values between a given range, inclusive.  Optionally get the range in reverse order.
     *
     * @param {K} lower
     * @param {K} higher
     * @param {boolean} [reverse]
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    rangeStream(lower: K, higher: K, reverse?: boolean): stream.Readable;
    /**
     * Get a collection of values from the keys at the given offset/limit. Optionally get the results from the end of the key set.
     *
     * @param {number} offset
     * @param {number} limit
     * @param {(key: K, data: string) => void} onRecord
     * @param {(err?: any) => void} onComplete
     * @param {boolean} [reverse]
     * @memberof SnapDB
     */
    offset(offset: number, limit: number, onRecord: (key: K, data: string) => void, onComplete: (err?: any) => void, reverse?: boolean): void;
    /**
     * Get a collection of values from the keys at the given offset/limit. Optionally get the results from the end of the key set.
     *
     * @param {boolean} [reverse]
     * @returns {Promise<AsyncIterableIterator<[K, string]>>}
     * @memberof SnapDB
     */
    offsetIt(offset: number, limit: number, reverse?: boolean): Promise<AsyncIterableIterator<[K, string]>>;
    /**
     * Get a collection of values from the keys at the given offset/limit. Optionally get the results from the end of the key set.
     *
     * @param {number} offset
     * @param {number} limit
     * @param {boolean} [reverse]
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    offsetStream(offset: number, limit: number, reverse?: boolean): stream.Readable;
    /**
     * Standard query for data
     *
     * @param {QueryArgs<K>} args
     * @param {((key: K, data: string|undefined) => void)} onRecord
     * @param {(err?: any) => void} onComplete
     * @memberof SnapDB
     */
    query(args: QueryArgs<K>, onRecord: (key: K, data: string | undefined) => void, onComplete: (err?: any) => void): void;
    /**
     * Get a collection of values from the keys at the given offset/limit. Optionally get the results from the end of the key set.
     *
     * @param {boolean} [reverse]
     * @returns {Promise<AsyncIterableIterator<[K, string]>>}
     * @memberof SnapDB
     */
    queryIt(args: QueryArgs<K>): Promise<AsyncIterableIterator<[K, string]>>;
    /**
     * Get a collection of values from the keys at the given offset/limit. Optionally get the results from the end of the key set.
     *
     * @param {QueryArgs<K>} args
     * @returns {stream.Readable}
     * @memberof SnapDB
     */
    queryStream(args: QueryArgs<K>): stream.Readable;
    /**
     * Check if a key exists or not.
     *
     * @param {K} key
     * @param {(err: any, exists: boolean) => void} [callback]
     * @returns {Promise<boolean>}
     * @memberof SnapDB
     */
    exists(key: K, callback?: (err: any, exists?: boolean) => void): Promise<boolean>;
    /**
     * Begins a transaction.
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    startTx(callback?: (error: any, txNum?: number) => void): Promise<number>;
    /**
     * Starts a transaction. (depreciated method, use .startTx() instead)
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    begin_transaction(): Promise<any>;
    /**
     * Ends a transaction
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    endTx(callback?: (err: any, txNum?: number) => void): Promise<any>;
    /**
     * Ends a transaction. (depreciated method, use .endTx() instead)
     *
     * @returns
     * @memberof SnapDB
     */
    end_transaction(): Promise<any>;
    /**
     * Closes database.  This isn't reversible, you must create a new SnapDB instance if you want to reconnect to this database without restarting your app.
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    close(callback?: (error?: any) => void): Promise<any>;
    /**
     * Empty all keys and values from database.
     *
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    empty(callback?: (err: any) => void): Promise<any>;
    /**
     * Perform an async action after the database is ready.  Does the action right away if the database is already ready.
     *
     * @private
     * @param {(cres: (value?: unknown) => void, crej: (value?: unknown) => void) => void} callback
     * @returns {Promise<any>}
     * @memberof SnapDB
     */
    private _doWhenReady;
    /**
     * Handle messages from the compactor thread.
     *
     * @private
     * @param {*} msg
     * @memberof SnapDB
     */
    private _onCompactorMessage;
    /**
     * Generate a message id and callback for sending messages to the worker thread.
     *
     * @private
     * @param {(data: any) => void} cb
     * @returns
     * @memberof SnapDB
     */
    private _msgID;
    /**
     * Make "any" type keys are numbers or strings
     *
     * @private
     * @param {*} key
     * @returns {*}
     * @memberof SnapDB
     */
    private _anyKey;
    /**
     * Handle work after compaction is finished.
     *
     * @private
     * @memberof SnapDB
     */
    private _cleanupCompaction;
    private _streamKeysAndValues;
    private _standardKeysAndValues;
    /**
     * Generate iterable for database queries.
     *
     * @private
     * @param {("all"|"offset"|"range")} mode
     * @param {any[]} args
     * @param {boolean} reverse
     * @param {string} progressEvent
     * @param {string} doneEvent
     * @returns {Promise<AsyncIterableIterator<[K, string]>>}
     * @memberof SnapDB
     */
    private _iterateKeysAndValues;
    /**
     * Generate new key iterator in the worker thread.
     *
     * @private
     * @param {("all" | "offset" | "range")} mode
     * @param {any[]} args
     * @param {boolean} reverse
     * @returns {Promise<string>}
     * @memberof SnapDB
     */
    private _asyncNewIterator;
    /**
     * Increment the worker thread key iterator.
     *
     * @private
     * @param {string} id
     * @returns {Promise<{ key: K, done: boolean }>}
     * @memberof SnapDB
     */
    private _asyncNextIterator;
    /**
     * Clear an iterator from the worker thread.
     *
     * @private
     * @param {string} id
     * @returns {Promise<void>}
     * @memberof SnapDB
     */
    private _asyncClearIteator;
}
