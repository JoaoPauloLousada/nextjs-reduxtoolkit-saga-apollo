Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Process nanoSQL query into AST
 *
 * @param {InanoSQLInstance} nSQL
 * @param {InanoSQLQuery} query
 * @returns {InanoSQLQueryAST}
 */
exports._generateAST = function (query) {
    var action = String(query.action).trim().toLowerCase();
    return {
        table: {
            str: typeof query.table === "string" ? query.table : "",
            arr: Array.isArray(query.table) ? query.table : [],
            prms: typeof query.table === "function" ? query.table : function () { return Promise.resolve({ rows: [], filtered: false }); }
        },
        action: action,
        args: {
            raw: query.actionArgs,
            select: action === "select" && query.actionArgs ? exports._processSelectArgs(query.actionArgs) : undefined,
        },
        where: exports._processWhere(query.where),
        having: exports._processWhere(query.having),
        range: exports._processOffsetLimit(query.offset || 0, query.limit || 0),
        orderBy: exports._processSortBy(query.orderBy),
        groupBy: exports._processSortBy(query.groupBy),
        distinct: query.distinct && Array.isArray(query.distinct) ? query.distinct.map(function (q) { return exports._processFunctionString(q); }) : undefined,
        graph: query.graph && !Array.isArray(query.graph) ? [query.graph] : query.graph,
        join: query.join && !Array.isArray(query.join) ? [query.join] : query.join,
        updateImmutable: query.updateImmutable,
        union: query.union
    };
};
/**
 * Process .orderBy() and .groupBy() arguments from user into AST.
 *
 * @param {(string[] | {[column: string]: string})} [sortArgs]
 * @returns {(undefined | InanoSQLProcessedSort[])}
 */
exports._processSortBy = function (sortArgs) {
    if (!sortArgs)
        return undefined;
    if (Array.isArray(sortArgs)) { // parse V2 format
        return sortArgs.map(function (v) {
            var splitValue = v.split(" ").map(function (s) { return s.trim(); });
            return exports._processSingleSortBy(splitValue[0], splitValue[1]);
        });
    }
    else { // parse V1 format
        return Object.keys(sortArgs).map(function (col) {
            var dir = sortArgs[col];
            return exports._processSingleSortBy(col, dir);
        });
    }
};
/**
 * Process single orderBy or groupBy objects into AST.
 *
 * @param {string} column
 * @param {string} [direction]
 * @returns {InanoSQLProcessedSort}
 */
exports._processSingleSortBy = function (column, direction) {
    var dir = String(direction || "").trim().toLowerCase() || "asc";
    return {
        dir: dir !== "asc" && dir !== "desc" ? "asc" : dir,
        value: exports._processFunctionString(column)
    };
};
/**
 * Converts SELECT arguments into an AST.
 *
 * @param {(string[] | undefined)} args
 * @returns
 */
exports._processSelectArgs = function (args) {
    // prevent undefined behavior
    if (!args || !Array.isArray(args))
        return undefined;
    return args.map(function (v) {
        var splitVal = String(v).split(/\s+as\s+/gmi).map(function (s) { return s.trim(); });
        return {
            value: exports._processFunctionString(splitVal[0]),
            as: splitVal[1],
        };
    });
};
/**
 * Process .offset() and .limit() queries from user into tuple.
 *
 * @param {number} offset
 * @param {number} limit
 * @returns {(undefined | [number, number])}
 */
exports._processOffsetLimit = function (offset, limit) {
    // prevent undefined behavior
    if (typeof offset !== "number" || typeof limit !== "number")
        return undefined;
    // no offset/limit
    if (offset + limit === 0)
        return undefined;
    return [offset, offset + limit];
};
/**
 * Convert a string that might contain a nested function call into an AST, or leave it as a string if it doesn't.
 *
 * @param {string} functionString
 * @returns {(string | InanoSQLFunctionQuery)}
 */
exports._processFunctionString = function (functionString) {
    // prevent undefined behavior
    if (typeof functionString !== "string")
        return "";
    var start = functionString.indexOf("(");
    // no functions in this string
    if (start === -1)
        return functionString;
    var end = functionString.lastIndexOf(")");
    if (end === -1) {
        throw new Error(functionString + " has no closing parentheses!");
    }
    var functionName = functionString.slice(0, start).toLowerCase();
    var functionArgs = functionString.slice(start + 1, end);
    // find all the commas that are not inside nested function calls
    var splitCommas = [-1];
    var isNestedFunction = 0;
    var i = 0;
    while (i < functionArgs.length) {
        var char = functionArgs[i];
        if (char === "(") {
            isNestedFunction++;
        }
        else if (char === ")") {
            isNestedFunction--;
        }
        else if (char === "," && isNestedFunction === 0) {
            splitCommas.push(i);
        }
        i++;
    }
    splitCommas.push(functionArgs.length);
    if (isNestedFunction !== 0) {
        throw new Error(functionString + " has incorrect nesting of functions!");
    }
    var processedArgs = splitCommas.length > 2 ? splitCommas.reduce(function (prev, cur, i) {
        if (splitCommas[i + 1] === undefined)
            return prev;
        var section = [splitCommas[i] + 1, splitCommas[i + 1]];
        var fnArg = functionArgs.slice.apply(functionArgs, section).trim();
        prev.push(exports._processFunctionString(fnArg));
        return prev;
    }, []) : [functionArgs.replace(/\,/gmi, "").trim()];
    return {
        name: functionName,
        args: processedArgs
    };
};
/**
 * Convert nested .where() arrays into AST
 *
 * @param {any[]} whereStatement
 * @returns {InanoSQLWhereQuery}
 */
exports._processArrayWhere = function (whereStatement) {
    // prevent undefined behavior
    if (Array.isArray(whereStatement) !== true) {
        throw new Error("Attempted to pass non array value into where array processing!");
    }
    if (typeof whereStatement[0] === "string") { // bottom of nested structure
        return {
            STMT: [
                exports._processFunctionString(whereStatement[0]),
                whereStatement[1],
                typeof whereStatement[2] === "string" ? exports._processFunctionString(whereStatement[2]) : whereStatement[2] // could be string, function string or anything else
            ]
        };
    }
    else {
        return {
            NESTED: whereStatement.map(function (where, i) {
                if (i % 2 === 1) {
                    var ANDOR = String(where).trim().toUpperCase();
                    if (ANDOR !== "AND" && ANDOR !== "OR") {
                        throw new Error("Malformed WHERE statement:" + JSON.stringify(whereStatement));
                    }
                    return { ANDOR: ANDOR };
                }
                return exports._processArrayWhere(where);
            })
        };
    }
};
/**
 * Convert user provided .where() arguments into an AST
 *
 * @param {(any[] | ((row: {[key: string]: any; }, i?: number) => boolean) | undefined)} whereStatement
 * @returns {(undefined | InanoSQLProcessedWhere)}
 */
exports._processWhere = function (whereStatement) {
    // no where statement
    if (typeof whereStatement === "undefined") {
        return undefined;
    }
    // where statement is js function
    if (typeof whereStatement === "function") {
        return {
            type: "fn",
            eval: whereStatement
        };
    }
    // where statement is array or array of arrays
    return {
        type: "arr",
        arr: exports._processArrayWhere(whereStatement)
    };
};
//# sourceMappingURL=query2-ast.js.map