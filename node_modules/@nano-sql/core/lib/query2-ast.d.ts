import { TableQueryResult, InanoSQLGraphArgs, InanoSQLJoinArgs, InanoSQLUnionArgs, InanoSQLQuery } from "./interfaces";
export interface InanoSQLQueryAST {
    table: {
        str: string;
        arr: any[];
        prms: (where?: any[] | ((row: {
            [key: string]: any;
        }, i?: number) => boolean)) => Promise<TableQueryResult>;
    };
    action: string;
    args: {
        raw?: any;
        select?: {
            as?: string;
            value: (string | InanoSQLFunctionQuery);
        }[];
    };
    where?: InanoSQLProcessedWhere;
    having?: InanoSQLProcessedWhere;
    range?: [number, number];
    orderBy?: InanoSQLProcessedSort[];
    groupBy?: InanoSQLProcessedSort[];
    distinct?: (InanoSQLFunctionQuery | string)[];
    graph?: InanoSQLGraphArgs[] | undefined;
    join?: InanoSQLJoinArgs[] | undefined;
    updateImmutable?: boolean;
    union?: InanoSQLUnionArgs;
}
export interface InanoSQLFunctionQuery {
    name: string;
    args: (string | InanoSQLFunctionQuery)[];
}
export interface InanoSQLProcessedSort {
    value: string | InanoSQLFunctionQuery;
    dir: "asc" | "desc";
}
export interface InanoSQLProcessedWhere {
    type: "fn" | "arr";
    eval?: (row: {
        [key: string]: any;
    }, i?: number) => boolean;
    arr?: InanoSQLWhereQuery;
}
export interface InanoSQLWhereQuery {
    ANDOR?: "AND" | "OR";
    STMT?: [string | InanoSQLFunctionQuery, string, any | InanoSQLFunctionQuery];
    NESTED?: InanoSQLWhereQuery[];
}
/**
 * Process nanoSQL query into AST
 *
 * @param {InanoSQLInstance} nSQL
 * @param {InanoSQLQuery} query
 * @returns {InanoSQLQueryAST}
 */
export declare const _generateAST: (query: InanoSQLQuery) => InanoSQLQueryAST;
/**
 * Process .orderBy() and .groupBy() arguments from user into AST.
 *
 * @param {(string[] | {[column: string]: string})} [sortArgs]
 * @returns {(undefined | InanoSQLProcessedSort[])}
 */
export declare const _processSortBy: (sortArgs?: string[] | {
    [column: string]: string;
} | undefined) => InanoSQLProcessedSort[] | undefined;
/**
 * Process single orderBy or groupBy objects into AST.
 *
 * @param {string} column
 * @param {string} [direction]
 * @returns {InanoSQLProcessedSort}
 */
export declare const _processSingleSortBy: (column: string, direction?: string | undefined) => InanoSQLProcessedSort;
/**
 * Converts SELECT arguments into an AST.
 *
 * @param {(string[] | undefined)} args
 * @returns
 */
export declare const _processSelectArgs: (args: string[] | undefined) => {
    value: string | InanoSQLFunctionQuery;
    as: string;
}[] | undefined;
/**
 * Process .offset() and .limit() queries from user into tuple.
 *
 * @param {number} offset
 * @param {number} limit
 * @returns {(undefined | [number, number])}
 */
export declare const _processOffsetLimit: (offset: number, limit: number) => [number, number] | undefined;
/**
 * Convert a string that might contain a nested function call into an AST, or leave it as a string if it doesn't.
 *
 * @param {string} functionString
 * @returns {(string | InanoSQLFunctionQuery)}
 */
export declare const _processFunctionString: (functionString: string) => string | InanoSQLFunctionQuery;
/**
 * Convert nested .where() arrays into AST
 *
 * @param {any[]} whereStatement
 * @returns {InanoSQLWhereQuery}
 */
export declare const _processArrayWhere: (whereStatement: any[]) => InanoSQLWhereQuery;
/**
 * Convert user provided .where() arguments into an AST
 *
 * @param {(any[] | ((row: {[key: string]: any; }, i?: number) => boolean) | undefined)} whereStatement
 * @returns {(undefined | InanoSQLProcessedWhere)}
 */
export declare const _processWhere: (whereStatement: any[] | ((row: {
    [key: string]: any;
}, i?: number | undefined) => boolean) | undefined) => InanoSQLProcessedWhere | undefined;
