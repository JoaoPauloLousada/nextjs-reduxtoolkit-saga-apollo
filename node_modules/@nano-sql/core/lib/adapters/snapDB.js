var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var interfaces_1 = require("../interfaces");
var utilities_1 = require("../utilities");
var memoryIndex_1 = require("./memoryIndex");
var snap_db_1 = require("snap-db");
var fs = require("fs");
var path = require("path");
var SnapDBAdapter = /** @class */ (function (_super) {
    __extends(SnapDBAdapter, _super);
    function SnapDBAdapter(snapDBArgs) {
        var _this = _super.call(this, true, false) || this;
        _this.snapDBArgs = snapDBArgs;
        _this.plugin = {
            name: "SnapDB Adapter",
            version: interfaces_1.VERSION,
            filters: [
                {
                    name: "config",
                    priority: 1000,
                    call: function (inputArgs, complete, cancel) {
                        if (inputArgs.res.path && inputArgs.res.path.length) {
                            _this._path = inputArgs.res.path;
                        }
                        complete(inputArgs);
                    }
                }
            ]
        };
        _this._path = typeof process !== "undefined" ? process.cwd() : "";
        _this._ai = {};
        _this._tableConfigs = {};
        _this._tables = {};
        return _this;
    }
    SnapDBAdapter.prototype.connect = function (id, complete, error) {
        this._id = id;
        this._baseFolder = path.join(this._path, "db_" + id);
        if (!fs.existsSync(this._baseFolder)) {
            fs.mkdirSync(this._baseFolder, { recursive: true });
        }
        this._tables["_ai_store"] = new snap_db_1.SnapDB({ dir: path.join(this._baseFolder, "_ai_store"), key: "string" });
        this._tables["_ai_store"].ready().then(function () {
            complete();
        }).catch(error);
    };
    SnapDBAdapter.prototype.createTable = function (tableName, tableData, complete, error) {
        var _this = this;
        this._tableConfigs[tableName] = tableData;
        this._tables[tableName] = new snap_db_1.SnapDB(__assign({ dir: path.join(this._baseFolder, tableName), key: tableData.isPkNum ? "float" : "string" }, this.snapDBArgs ? this.snapDBArgs : {}));
        if (this._tableConfigs[tableName].ai) {
            this._tables["_ai_store"].get(tableName).then(function (aiValue) {
                _this._ai[tableName] = parseInt(aiValue || "0");
                _this._tables[tableName].ready().then(complete).catch(error);
            }).catch(function () {
                _this._ai[tableName] = 0;
                _this._tables[tableName].ready().then(complete).catch(error);
            });
        }
        else {
            this._tables[tableName].ready().then(complete).catch(error);
        }
    };
    SnapDBAdapter.prototype.batch = function (table, actions, success, error) {
        var _this = this;
        this._tables[table].begin_transaction().then(function () {
            return Promise.all(actions.map(function (a) {
                if (a.type === "put") {
                    return _this._tables[table].put(utilities_1.deepGet(_this._tableConfigs[table].pkCol, a.data), JSON.stringify(a.data));
                }
                else {
                    return _this._tables[table].delete(a.data);
                }
            }));
        }).then(function () {
            return _this._tables[table].end_transaction();
        }).then(success).catch(error);
    };
    SnapDBAdapter.prototype.dropTable = function (tableName, complete, error) {
        var _this = this;
        this._tables["_ai_store"].delete(tableName).then(function () {
            _this._ai[tableName] = 0;
            return _this._tables[tableName].empty();
        }).then(function () {
            return _this._tables[tableName].close();
        }).then(function () {
            delete _this._tables[tableName];
            delete _this._tableConfigs[tableName];
            complete();
        }).catch(error);
    };
    SnapDBAdapter.prototype.disconnect = function (complete, error) {
        var _this = this;
        utilities_1.chainAsync(Object.keys(this._tables), function (table, i, next, err) {
            _this._tables[table].close().then(function () {
                delete _this._tables[table];
                delete _this._tableConfigs[table];
                next();
            }).catch(err);
        }).then(complete).catch(error);
    };
    SnapDBAdapter.prototype.write = function (table, pk, row, complete, error) {
        var _this = this;
        pk = pk || utilities_1.generateID(this._tableConfigs[table].pkType, this._ai[table] + 1);
        if (typeof pk === "undefined") {
            error(new Error("Can't add a row without a primary key!"));
            return;
        }
        if (this._tableConfigs[table].ai) {
            this._ai[table] = Math.max(this._ai[table] || 0, pk);
        }
        utilities_1.deepSet(this._tableConfigs[table].pkCol, row, pk);
        this._tables[table].put(pk, JSON.stringify(row)).then(function () {
            if (_this._tableConfigs[table].ai) {
                return _this._tables["_ai_store"].put(table, String(_this._ai[table]));
            }
            return Promise.resolve();
        }).then(function () {
            complete(pk);
        }).catch(error);
    };
    SnapDBAdapter.prototype.read = function (table, pk, complete, error) {
        this._tables[table].get(pk).then(function (row) {
            // found
            complete(JSON.parse(row));
        }).catch(function () {
            // row not found
            complete(undefined);
        });
    };
    SnapDBAdapter.prototype.delete = function (table, pk, complete, error) {
        this._tables[table].delete(pk).then(function () {
            complete();
        }).catch(error);
    };
    SnapDBAdapter.prototype.readMulti = function (table, type, offsetOrLow, limitOrHigh, reverse, onRow, complete, error) {
        var ct = 0;
        switch (type) {
            case "range":
                this._tables[table].range(offsetOrLow, limitOrHigh, function (key, data) {
                    onRow(JSON.parse(data), ct);
                    ct++;
                }, function (err) {
                    if (err) {
                        error(err);
                    }
                    else {
                        complete();
                    }
                }, reverse);
                break;
            case "offset":
                var ranges = reverse ? [(offsetOrLow || 0) + 1, limitOrHigh] : [(offsetOrLow || 0), limitOrHigh];
                this._tables[table].offset(ranges[0], ranges[1], function (key, data) {
                    onRow(JSON.parse(data), ct);
                    ct++;
                }, function (err) {
                    if (err) {
                        error(err);
                    }
                    else {
                        complete();
                    }
                }, reverse);
                break;
            case "all":
                this._tables[table].getAll(function (key, data) {
                    onRow(JSON.parse(data), ct);
                    ct++;
                }, function (err) {
                    if (err) {
                        error(err);
                    }
                    else {
                        complete();
                    }
                }, reverse);
                break;
        }
    };
    SnapDBAdapter.prototype.getTableIndex = function (table, complete, error) {
        var idx = [];
        this._tables[table].getAllKeys(function (key) {
            idx.push(key);
        }, function (err) {
            if (err) {
                error(err);
            }
            else {
                complete(idx);
            }
        });
    };
    SnapDBAdapter.prototype.getTableIndexLength = function (table, complete, error) {
        this._tables[table].getCount().then(complete).catch(error);
    };
    return SnapDBAdapter;
}(memoryIndex_1.nanoSQLMemoryIndex));
exports.SnapDBAdapter = SnapDBAdapter;
exports.rimraf = function (dir_path) {
    if (fs.existsSync(dir_path)) {
        fs.readdirSync(dir_path).forEach(function (entry) {
            var entry_path = path.join(dir_path, entry);
            if (fs.lstatSync(entry_path).isDirectory()) {
                exports.rimraf(entry_path);
            }
            else {
                fs.unlinkSync(entry_path);
            }
        });
        fs.rmdirSync(dir_path);
    }
};
//# sourceMappingURL=snapDB.js.map